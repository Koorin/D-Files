<!--
    D-Files Êñá‰ª∂ÊòìÂÆπ
    
    Copyright 2025 Koorin

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="assets/magicat.png" sizes="32x32">
  <title>Êñá‰ª∂ÊòìÂÆπ D-Files</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background-color: #2e3344;
      color: #f7f8fc;
      padding: 2rem;
      margin: auto;
      line-height: 1.6;
      position: relative;
      z-index: 1;
      background-attachment: fixed;
    }

    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: 1rem;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
    }

    input[type="file"] {
      width:180px;
      font-size: 1rem;
      color: inherit;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    input[type="file"]::file-selector-button {
      background-color: transparent;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 0;
      font: inherit;
    }
    input[type="file"]:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }

    .action-btn , .restorebtn{
      padding: 0.665rem 1.888rem;
      font-size: 1rem;
      border-radius: 0.375rem;
      background-color: #6366f1;
      color: white;
      border: none;
      cursor: pointer;
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .uniButton {
      background-color: #6366f1;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 1rem;
    }
    .uniButton:hover , .fakebtn:hover , .action-btn:hover , .restorebtn:hover {
      background-color: #4f46e5;
    }
    
    .download-link {
      display: inline-block;
      margin-top: 0.95rem;
      color: #2563eb;
      text-decoration: none;
      white-space: normal;
      word-break: break-all;
    }
    .hidden {
      display: none !important;
    }
    .preview {
      margin-top: 1rem;
      max-height: 100%;
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    body.normal-mode {
      background-color: #f7f8fc;
      color: #333333;
    }

    #modeToggleBtn, #customizeBtn , #helpBtn{
      display: inline-block;
      font-size: 2rem;
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 50%;
      cursor: pointer;
      position: fixed;
      z-index: 1000;
      text-shadow: 0px 0px 1rem rgba(0, 0, 0, 0.8); 
    }
    #modeToggleBtn {
      top: 0;
      right: 8px;
    }
    #customizeBtn {
      top: 50px;
      right: 5px;
    }
    #helpBtn {
      top: 2px;
      right: 50px;
    }
    #modeToggleBtn:hover, #customizeBtn:hover, #helpBtn:hover {
      transform: scale(1.2);
      transition: all 0.3s ease;
    }

    #overlayPanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
      background-color: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: background-color 0.3s, opacity 0.3s, filter 0.3s;
      display: none;
    }
    #customizePanel {
      position: fixed;
      top: 4rem;
      right: 80px;
      max-height: 80vh;
      width:360px;
      overflow-y: auto;
      background: rgba(144, 151, 172, 0.1);
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 999;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: max-height 0.3s ease;
    }
    #resetBtn {
      position: relative;
      margin: 0;
    }
    
    .status-indicator {
      display: inline-block;
      margin-left: 10px;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      background-color: #6366f1;
      color: white;
      opacity: 0;
      transition: opacity 0.3s ease;
      vertical-align: middle;
    }
    .status-indicator.active {
      opacity: 1;
    }
    .status-indicator.success {
      background-color: #10b981;
    }
    .status-indicator.error {
      background-color: #ef4444;
    }
    .status-indicator.warning {
      background-color: #f59e0b;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      margin-bottom: 0.75rem;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="range"] {
      flex: 1;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      cursor:pointer;
      min-width: 50px;
      outline: none;
      transition: background 0.3s;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="number"] {
      width: 60px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: inherit;
      border-radius: 4px;
      min-width: 10px;
      text-align: center;
      padding: 2px 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .color-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .semi-transparent-input {
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      padding: 10px 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      border-radius: 6px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .transelect {
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .ekinput {
      text-align: center;
      height: 38px;
      width: 130px;
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      border-radius: 6px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .custom-file-btn {
      display: inline-block;
      padding: 0.5rem 0.8rem;
      border-radius: 6px;
      font-size: 0.95rem;
      white-space: normal;
      word-break: break-all;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      color: inherit;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .custom-file-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }
    .bgbtn {
      display:block;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      font-size: 0.95rem;
      text-align: center;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .bgbtn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }

    .fileRow {
      margin-top: 0.5rem;
    }
    h1 , p {
      margin: 0.5rem;
    }
    p{
      margin-bottom: 1rem;
    }
    h2 {
      margin-top: 0;    
      border-bottom: 1px solid rgba(255,255,255,0.2);
      padding-bottom: 0.5rem;
    }

    .fakebtn {
      padding: 0.5rem 0.5rem;
      border-radius: 6px;
      font-size: 0.95rem;
      cursor: pointer;
      color: white;
      background: #6366f1;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .fakebtn:hover {
      background: #4f46e5;
    }
    .nobtn {
      display: none;
    }
    .fakebtn:has(.nobtn:checked) {
      background-color: #2b21e7;
      padding: 0.5rem 0.5rem;
    }
    .fakebtn:has(.nobtn:checked):hover {
      background-color: #1d15b3;
    }
    .btnlabel {
      border-radius: 4px;
      user-select: none;
    }
    .keysets {
      display: flex;
      position: relative;
      align-items: center;
      gap: 0.4rem;
      min-height: 1rem;
    }
    #keyPanel {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      box-sizing: border-box;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      flex: 1;
      min-width: 380px;
      display: table;
    }
    .card2 {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .title-section {
      display: flex;
      justify-content: center;
    }
    .header-section {
      display: grid;
      justify-content: center;
      text-align: center;
      width: 1280px;
      box-sizing: border-box;
      min-width: 380px;
      margin-bottom: 1rem;
      padding: 1rem;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    @media (max-width: 600px), (max-height: 450px) {
      #customizePanel {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        max-height: none;
        border-radius: 0;
        overflow-y: auto;
        box-shadow: none;
        box-sizing: border-box; 
      }
      .bgbtn {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        max-height: none;
        border-radius: 0;
        overflow-y: auto;
        padding: 1rem;
        box-shadow: none;
        box-sizing: border-box; 
      }
      #modeToggleBtn, #customizeBtn, #helpBtn{
        font-size: medium;
        }
      #modeToggleBtn {
        top: 3px;
        right: 5px;
      }
      #customizeBtn {
        top: 30px;
        right: 4px;
        }
      #helpBtn {
        top: 4px;
        right: 30px;
      }
      #modeToggleBtn:hover, #customizeBtn:hover {
        background: none;
        backdrop-filter:unset;
        -webkit-backdrop-filter: unset;
      }
      .action-btn:hover , .restorebtn:hover {
        background-color: #6366f1;
      }
      .color-group {
        margin-top: 2.5rem;
      }
      .container {
        padding: 0.8rem;
      }
      .header-section {
        width: 100%;
        min-width: auto;
        padding: 1.25rem;
        box-sizing: border-box;
        text-align: center;
      }
      .keysets {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
      }
      .keysets .uniButton, #clearKeyBtn {
        width: 200px;
        max-width: 90%;
        box-sizing: border-box;
      }
      #keyPanel {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.45rem;
        width: 100%;
        margin-top: 0.5rem;
      }
      .ekinput {
        width: 160px;
        max-width: 90%;
      }
      .card2 {
        display: flex;
        gap: 1rem;
        align-items: stretch;
      }
      .card {
        min-width: auto;
        width: 100%;
        box-sizing: border-box;
      }
      h1 { 
        font-size: 1.6rem; 
      }
      p  { 
        font-size: 0.95rem; margin-bottom: .75rem; 
      }
      .custom-file-btn {
        width: 220px;
        max-width: 90%;
        text-align: center;
      }
      .preview, .download-link {
        max-width: 100%;
      }
      .help-tip { max-width: 92vw; font-size: 0.95rem; }
    }

    .progress-btn{
      position: relative;
      overflow: hidden;
      --progress: 0%;
      transition: color .15s linear;
    }

    .progress-btn .label{
      position: relative;
      z-index: 3;
      pointer-events: none;
    }

    .progress-btn::before{
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: var(--progress);
      z-index: 1;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(95,77,255,0.95) 0%, rgba(80,65,240,0.95) 100%);
      mix-blend-mode: normal;
      transition: width 120ms linear;
      opacity: 0.98;
    }

    .progress-btn.progressing .label{
      z-index: 4;
    }

    @keyframes indeterminate-slide {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }

    @keyframes spin-center {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    @keyframes spin-bottom {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    .rotate-center {
      transform-origin: center center !important;
      animation: spin-center 700ms cubic-bezier(.2,.9,.2,1);
    }

    .rotate-bottom {
      transform-origin: center bottom !important;
      animation: spin-bottom 700ms cubic-bezier(.2,.9,.2,1);
    }
    .progress-btn.indeterminate::before{
      width: 35%;
      left: -35%;
      background: linear-gradient(90deg, rgba(95,77,255,0.95), rgba(120,100,255,0.95));
      transition: none;
      animation: indeterminate-slide 1.1s linear infinite;
    }

    .progress-btn.finished::before{
      transition: opacity 240ms ease, width 240ms ease;
      opacity: 0;
    }
    #helpOverlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 2000;
      display: none;
      pointer-events: auto;
    }

    .help-tip {
      position: fixed;
      max-width: 340px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      z-index: 2010;
      font-size: 0.95rem;
      line-height: 1.3;
      transform-origin: center top;
      transition: transform 160ms ease, opacity 160ms ease;
      pointer-events: auto;
      backdrop-filter: blur(4px);
    }
  
    .help-tip h3 { margin: 0 0 6px 0; font-size: 1rem; color: #fff; }
    .help-tip p { margin: 0; font-size: 0.92rem; color: rgba(255,255,255,0.92); }

    .help-highlight {
      position: fixed;
      border-radius: 6px;
      box-shadow: 0 1px 24px rgb(255, 254, 210), 0 0 0 3px rgba(255, 254, 210, 0.8) inset;
      z-index: 2005; 
      pointer-events: none;
      transition: opacity 300ms ease, transform 300ms ease;
      opacity: 0;
    }

  </style>
</head>
<body>
  <div class="container">
    <div id="overlayPanel"></div>
      <button id="modeToggleBtn" title="ÂàáÊç¢ÊòæÁ§∫Ê®°Âºè">üí°</button>
      <button id="customizeBtn" class="hidden" title="Â§ñËßÇËÆæÁΩÆ">‚öôÔ∏è</button>
      <button id="helpBtn" title="Êü•ÁúãÂ∏ÆÂä©">‚ùì</button>
      <div id="helpOverlay" aria-hidden="true"></div>
    <div id="customizePanel" class="hidden">
      <div class="color-group">
        <label>ÊñáÂ≠óÈ¢úËâ≤</label>
        <div id="textColorInput"></div>
        <label>ËÉåÊôØËâ≤</label>
        <div id="bgColorInput"></div>
        <label>ÂâçÊôØËâ≤</label>
        <div id="overlayColorInput"></div>
      </div>

      <div class="slider-group">
        <label for ="overlayOpacityInput">ÈÄèÊòéÂ∫¶</label>
        <input type="range" id="overlayOpacityInput" min="0" max="100" value="100">
        <input type="number" id="overlayOpacityValue" min="0" max="100" value="100">
      </div>
      <div class="slider-group">
        <label for = "overlayBlurInput">Ê®°Á≥äÂ∫¶</label>
        <input type="range" id="overlayBlurInput" min="0" max="100" value="5">
        <input type="number" id="overlayBlurValue" min="0" max="100" value="5">
      </div>
      <div class="fileRow">
        <label class="bgbtn" id="bgLabel">
          <span id="bgText">ÈÄâÊã©ËÉåÊôØÂõæ</span>
          <input type="file" id="bgImageInput" accept="image/*" hidden>
        </label>
      </div>
      <div class="semi-transparent-input">
        <label>ËÉåÊôØÂõæÊòæÁ§∫ÊñπÂºèÔºö
          <select id="bgDisplayMode" class="transelect">
            <option value="stretch">Êãâ‰º∏</option>
            <option value="cover">Â°´ÂÖÖ</option>
            <option value="repeat">Âπ≥Èì∫</option>
            <option value="center">Â±Ö‰∏≠</option>
          </select>
        </label>
        <button id="resetBtn" class="uniButton">ËøòÂéüÈªòËÆ§ÂÄº</button>
      </div>
      
    </div>
    <div class="title-section">
    <div class="header-section">
      <h1>ü§î Êñá‰ª∂ÊòìÂÆπ ‚òùüèªü§ì</h1>
      <p>‚ïÆÔºàÔø£‚ñΩÔø£Ôºâ‚ï≠ ÂèØÂ∞Ü‰ªªÊÑèÊñá‰ª∂ÂèòÊàêÂÖ∂‰ªñÊñá‰ª∂Ôºå‰πüÂèØÊèêÂèñË¢´ÈöêËóèÁöÑÂéüÊñá‰ª∂„ÄÇ</p>
        <div class="keysets">
          <button id="keycfg" class="uniButton" onclick="toggleKey()">Âä†ÂØÜÂ§ÑÁêÜÈÖçÁΩÆ</button>
            <div id="keyPanel" class="hidden">
              <label class="fakebtn"><input type="checkbox" id="useAdvancedAES" class="nobtn"><span class="btnlabel">È´òÁ∫ßÂä†ÂØÜ</span></label>
              <input type="text" id="keyInput" class="ekinput" placeholder="ËæìÂÖ•ÂØÜÈí•ÔºàÂèØÈÄâÔºâ">
              <label class="fakebtn"><input type="checkbox" id="skipEncryption" class="nobtn"><span class="btnlabel">Ë∑≥ËøáÂä†ÂØÜ</span></label>
            </div>
          <button id="clearKeyBtn" class="uniButton" onclick="clearKeyMapping()">Ê∏ÖÁ©∫Êú¨Âú∞ÂØÜÈí•ËÆ∞ÂøÜ</button>
          <span id="clearKeyStatus" class="status-indicator"></span>
        </div>
    </div>
    </div>

    <div class="card2">
      <div class="card" data-help-title="ÁîüÊàê‰º™Ë£ÖÊñá‰ª∂" data-help-text="Ë°®Èù¢Êñá‰ª∂ÔºöÈöêËóèÊñá‰ª∂ÊîπÂ§¥Êç¢Èù¢ÂêéÁöÑÊ†∑Â≠ê„ÄÇÁîüÊàêÂêéÁöÑ‰º™Ë£ÖÊñá‰ª∂Èô§Â§ßÂ∞èÂ§ñÊó†ËÆ∫Â§ñËßÇËøòÊòØÂäüËÉΩÊÄßÂùá‰∏éË°®Èù¢Êñá‰ª∂ÂÆåÂÖ®‰∏ÄËá¥„ÄÇÂèØ‰∏ÄÊ¨°ÊÄßÂ∞ÜÂ§çÊï∞Êñá‰ª∂Ëá™Âä®ÊâìÂåÖÂπ∂‰º™Ë£Ö‰∏∫‰∏Ä‰∏™Êñá‰ª∂„ÄÇÁî®ÂØÜÈí•Âä†ÂØÜÁîüÊàêÊñá‰ª∂Êó∂Ôºå‰ºöËá™Âä®ËÆ∞ÂøÜÁîüÊàêÊñá‰ª∂ÂêçÁöÑÂØπÂ∫îÂØÜÈí•„ÄÇ">
        <h2>ÁîüÊàê‰º™Ë£ÖÊñá‰ª∂</h2>
        <div class="fileRow">
          <label class="custom-file-btn" id="coverLabel">
            <span id="coverText">ËØ∑ÈÄâÊã©Ë°®Èù¢Êñá‰ª∂</span>
            <input type="file" id="fakeCover" hidden>
          </label>
        </div>
  
        <div class="fileRow">
          <label class="custom-file-btn" id="hiddenLabel">
            <span id="hiddenText">ËØ∑ÈÄâÊã©ÈöêËóèÊñá‰ª∂</span>
            <input type="file" id="fakeInput" multiple hidden>
          </label>
        </div>      
        <button class="action-btn progress-btn" onclick="disguiseFile()"><span class="label">üòé Disguise Ready</span></button><span id="disguiseStatus" class="status-indicator"></span>
        <div id="disguiseResult"></div>
        <div id="disguisePreview"></div>
      </div>

      <div class="card" data-help-title="ËøòÂéü‰º™Ë£ÖÊñá‰ª∂" data-help-text="ÂΩìË∑≥ËøáÂä†ÂØÜÊú™ÂêØÁî®Êó∂Ôºå‰ºöÂ∞ùËØïÂåπÈÖçÁîüÊàêËøáÁöÑÊñá‰ª∂ÂØπÂ∫îÂØÜÈí•„ÄÇËøòÂéüÊàêÂäüÊó∂ÔºåËá™Âä®Â±ïÁ§∫ÂèØÈ¢ÑËßàÁöÑÊñá‰ª∂„ÄÇÂØÜÈí•ÈîôËØØËøòÂéüÂ§±Ë¥•Êó∂Âè™ËÉΩÊèêÂèñÂá∫Êó†ÊïàÊñá‰ª∂„ÄÇ">
        <h2>ËøòÂéü‰º™Ë£ÖÊñá‰ª∂</h2>
          <div class="fileRow">
            <label class="custom-file-btn" id="restoreLabel">
            <span id="restoreText">ËØ∑ÈÄâÊã©‰º™Ë£ÖÊñá‰ª∂</span>
            <input type="file" id="restoreInput" hidden>
            </label>
          </div>      
        <button class="restorebtn progress-btn" onclick="restoreFile()"><span class="label">ü§†üëêÊè≠ÂºÄ‰ªñ‰ª¨ÁöÑÈù¢Á∫±</span></button><span id="restoreStatus" class="status-indicator"></span>
        <div id="restoreResult"></div>
        <div id="restorePreview"></div>
      </div>
    </div>
    
    <script>
    
      function executeCodeSafely(code, name) {
        const script = document.createElement('script');
        script.textContent = `//# sourceURL=${name}_cache.js\n${code}`;
        document.head.appendChild(script).remove();
      }

      const LIBRARY_URLS = {
        zip: "https://cdn.jsdelivr.net/npm/@zip.js/zip.js/dist/zip.min.js",
        pickr: "https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js",
        pickrCSS: "https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/monolith.min.css"
      };
      const CACHE_KEYS = {
        zip: "cachedZipJS",
        pickr: "cachedPickrJS",
        pickrCSS: "cachedPickrCSS"
      };
      async function loadLibrary(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        const cached = localStorage.getItem(key);      
        if (cached) {
          try {
            if (isCSS) {
              injectStyle(cached);
            } else {
              executeCodeSafely(cached, name);
            }
          } catch (e) {
            await fetchAndCacheLibrary(name, isCSS);
          }
          tryUpdateLibraryInBackground(name, isCSS);
        } else {
          await fetchAndCacheLibrary(name, isCSS);
        }
      }
      async function fetchAndCacheLibrary(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        try {
          const response = await fetch(url, { cache: "no-store" });
          const code = await response.text();
          localStorage.setItem(key, code);
          if (isCSS) {
            injectStyle(code);
          } else {
            executeCodeSafely(code, name);
          }
        } catch (err) {
          alert(`${name} Âä†ËΩΩÂ§±Ë¥•Ôºå‰∏îÊó†Êú¨Âú∞ÁºìÂ≠òÔºåÂäüËÉΩ‰∏çÂèØÁî®`);
          throw err;
        }
      }
      async function tryUpdateLibraryInBackground(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        try {
          const response = await fetch(url, { cache: "no-store" });
          const code = await response.text();
          localStorage.setItem(key, code);
        } catch (err) {
        }
      }
      function injectStyle(cssCode) {
        const style = document.createElement("style");
        style.textContent = cssCode;
        document.head.appendChild(style);
      }
    
      function getRandomStatus(type) {
        const random = Math.random();
      
        if (type === "disguise-processing") {
          if (random < 0.3) {
            const phrases = [
              "Â∞ëÂ•≥Á•àÁ•∑‰∏≠...",
              "No time to wasteüò°",
              "Â∞ëÂ•≥ÊäòÂØø‰∏≠Œ£(„Å£ ¬∞–î ¬∞;)„Å£" ,
              "Now you see me, soon you won't",
              "A really big fxxking hole coming right up!",
              "oiiaioooooiai"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "Â§ÑÁêÜ‰∏≠...";
        }

        if (type === "disguise-done") {
          if (random < 0.3) {
            const phrases = [
              "Ê≠£Âú®ÂÅ∑ÂêÉÁîµÂºßÊòüÔºÅ",
              "SÂ±ûÊÄßÂ§ßÁàÜÂèëÔºÅShare!",
              "Ë±ÜÊµÜ~",
              "El Psy Kongroo"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "Â§ÑÁêÜÂÆåÊàêÔºÅ";
        }
      
        if (type === "reveal-processing") {
          if (random < 0.3) { 
            const phrases = [
               "ü§†üëêÈù¢Á∫±ÂêéÈù¢ËóèÁùÄ‰ªÄ‰πàÂë¢Ôºü",
               "üéµÊ≠£Âú®Ê≤ªÁñóËá™Â∑±üé∂",
               "If you want it,then you have to take it",
               "oiiaioooooiai",
               "Open Sesame!"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "Â§ÑÁêÜ‰∏≠...";
        }
      
        if (type === "reveal-done") {
          if (random < 0.3) {
            const phrases = [
              "ü§†üëê‰ºüÂ§ßÁöÑÊè≠ÂπïË°®ÊºîÔºÅ", 
              "ÊòØÊàëÂñúÊ¨¢ÁöÑÂÜÖÂÆπÔºåÁõ¥Êé•ÊãøÊù•„ÄÇ",
              "El Psy Kongroo"
            ];
          return phrases[Math.floor(Math.random() * phrases.length)];
          }      
          return "Â§ÑÁêÜÂÆåÊàê";
        }
      }    

      function bindSliderWithNumber(sliderId, numberId, onChange) {
        const slider = document.getElementById(sliderId);
        const number = document.getElementById(numberId);
        slider.addEventListener("input", () => {
          number.value = slider.value;
          if (onChange) onChange(slider.value);
        });
        number.addEventListener("input", () => {
          slider.value = number.value;
          if (onChange) onChange(slider.value);
        });
      }
    
      function updateStatus(element, text, ok = null, options = {}) {
        if (!element) return;

        const cfg = {
          autoHide: options.autoHide === undefined ? true : Boolean(options.autoHide),
          delay: typeof options.delay === 'number' ? options.delay : 2000
        };

        if (element._statusTimeout) {
          clearTimeout(element._statusTimeout);
          element._statusTimeout = null;
        }

        if (!text) {
          element.textContent = "";
          element.classList.remove("active");
          element.classList.remove(
            "status-ok", "status-success", "ok", "success",
            "status-fail", "status-error", "fail", "error",
            "status-warning", "warning", "warn"
          );
          return;
        }
      
        element.textContent = text;
        element.classList.add("active");
        element.classList.remove(
          "status-ok", "status-success", "ok", "success",
          "status-fail", "status-error", "fail", "error",
          "status-warning", "warning", "warn"
        );
      
        if (ok === true) {
          element.classList.add("status-ok", "status-success", "ok", "success");
        } else if (ok === false) {
          element.classList.add("status-fail", "status-error", "fail", "error");
        } else if (ok === "warning" || ok === "warn") {
          element.classList.add("status-warning", "warning", "warn");
        }

        const isProcessingText = text === "Â§ÑÁêÜ‰∏≠...";
        if (cfg.autoHide && !isProcessingText) {
          element._statusTimeout = setTimeout(() => {
            element.classList.remove("active");
            element._statusTimeout = null;
          }, cfg.delay);
        }
      }
    
      function clearKeyMapping() {
        localStorage.removeItem("key_mapping");
        updateStatus(document.getElementById("clearKeyStatus"), "ÂØÜÈí•ÈÖçÁΩÆÂ∑≤Ê∏ÖÈô§", true);
      }
    
      function toggleKey() {
        const clearBtn = document.getElementById("clearKeyBtn");
        const keyPanel = document.getElementById("keyPanel");
        const toggleBtn = event.target;
        clearBtn.classList.toggle("hidden");
        keyPanel.classList.toggle("hidden");
        const isNowVisible = !clearBtn.classList.contains("hidden");
        toggleBtn.textContent = isNowVisible ? "ÈöêËóèÂä†ÂØÜÈÖçÁΩÆ" : "Âä†ÂØÜÂ§ÑÁêÜÈÖçÁΩÆ";
        localStorage.setItem("keyPanelOpen", isNowVisible ? "true" : "false");
      }

      function renderPreview(container, mime, url) {
        container.innerHTML = "";
        if (!mime || !url) return;
      
        if (mime.startsWith("image/")) {
          const el = document.createElement("img");
          el.src = url; el.className = "preview";
          container.appendChild(el);
          return;
        }
        if (mime.startsWith("audio/")) {
          const el = document.createElement("audio");
          el.controls = true; el.src = url; container.appendChild(el); return;
        }
        if (mime.startsWith("video/")) {
          const el = document.createElement("video");
          el.controls = true; el.src = url; el.className = "preview"; container.appendChild(el); return;
        }
        if (mime === "application/pdf") {
          const el = document.createElement("iframe");
          el.src = url; el.className = "preview"; container.appendChild(el); return;
        }
        if (mime.startsWith("text/") || mime === "application/json" || mime === "application/javascript" || mime === "text/csv") {
          fetch(url).then(res => res.text()).then(text => {
            const pre = document.createElement("pre");
            pre.textContent = text;
            container.appendChild(pre);
          }).catch(()=> {
            const note = document.createElement("div");
            note.textContent = "ÊñáÊú¨ËØªÂèñÂ§±Ë¥•„ÄÇ";
            container.appendChild(note);
          });
          return;
        }
      
        const note = document.createElement("div");
        note.textContent = "ËØ•Êñá‰ª∂Á±ªÂûãÊöÇ‰∏çÊîØÊåÅÂú®Á∫øÈ¢ÑËßà„ÄÇ";
        container.appendChild(note);
      }
    
      function createXORTransformStream(key) {
        const encoder = new TextEncoder();
        const keyBytes = encoder.encode(key);
        return new TransformStream({
          transform(chunk, controller) {
            const output = new Uint8Array(chunk.length);
            for (let i = 0; i < chunk.length; i++) {
              output[i] = chunk[i] ^ keyBytes[i % keyBytes.length];
            }
            controller.enqueue(output);
          }
        });
      }
    
    function createAesCtrTransformStream(password, nonce, isEncrypt) {
      const BLOCK_SIZE = 24 * 1024;
      const keyPromise = (async () => {
        const pwBytes = new TextEncoder().encode(password);
        const hash = await crypto.subtle.digest('SHA-256', pwBytes);
        return crypto.subtle.importKey("raw", hash, { name: "AES-CTR" }, false, ["encrypt", "decrypt"]);
      })();

      let globalBlockCounter = 0;

      function makeCounterForBlock(blockCounter) {
        const counter = new Uint8Array(16);
        counter.set(nonce, 0);
        const view = new DataView(counter.buffer);
        view.setUint32(12, blockCounter, false);
        return counter;
      }

      return new TransformStream({
        async transform(chunk, controller) {
          const key = await keyPromise;
          const uint8Chunk = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);

          let offset = 0;
          while (offset < uint8Chunk.length) {
            const slice = uint8Chunk.subarray(offset, offset + BLOCK_SIZE);

            const startBlockIndex = globalBlockCounter;
            const counter = makeCounterForBlock(startBlockIndex);
            const algo = { name: "AES-CTR", counter: counter, length: 128 };
            const processedBuffer = await crypto.subtle[isEncrypt ? "encrypt" : "decrypt"](algo, key, slice);
            const processed = new Uint8Array(processedBuffer);
            controller.enqueue(processed);
            const blocksProcessed = Math.ceil(slice.length / 16);
            globalBlockCounter += blocksProcessed;
            offset += slice.length;
          }
        }
      });
    }
    
      async function createZipBlob(files) {
            const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
            for (const file of files) {
              await writer.add(file.name, new zip.BlobReader(file));
            }
            return await writer.close();
      }
      
      function getExtensionMime(ext) {
        const mimes = {
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          png: "image/png",
          apng: "image/apng",
          gif: "image/gif",
          webp: "image/webp",
          bmp: "image/bmp",
          ico: "image/x-icon",
          mp3: "audio/mpeg",
          aac: "audio/aac",
          wav: "audio/wav",
          flac: "audio/flac",
          ogg: "audio/ogg",
          mp4: "video/mp4",
          webm: "video/webm",
          pdf: "application/pdf",
          txt: "text/plain",
          json: "application/json",
          js: "application/javascript",
          csv: "text/csv",
          html: "text/html"
        };
        return mimes[ext.toLowerCase()] || "application/octet-stream";
      }
    
      function saveKeyMapping(filename, key) {
        if (!key) return;
        let existingMap = {};
        try {
          existingMap = JSON.parse(localStorage.getItem("key_mapping") || "{}");
        } catch (e) {}
        existingMap[filename] = key;
        localStorage.setItem("key_mapping", JSON.stringify(existingMap));
      }
    
      function openIDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("bgStore", 1);
          request.onupgradeneeded = () => {
            const db = request.result;
            db.createObjectStore("images");
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
    
      async function saveBgToIDB(dataURL) {
        const db = await openIDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("images", "readwrite");
          const store = tx.objectStore("images");
          const request = store.put(dataURL, "bgImage");
        
          request.onsuccess = () => {
            tx.oncomplete = () => {
              resolve();
            };
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
    
      async function loadBgFromIDB() {
        const db = await openIDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("images", "readonly");
          const store = tx.objectStore("images");
          const request = store.get("bgImage");
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
      
      async function disguiseFile() {
        const disguiseStatus = document.getElementById("disguiseStatus");
        const btn = document.querySelector('button[onclick="disguiseFile()"]') || document.querySelector('.action-btn');
        try {
          updateStatus(disguiseStatus, getRandomStatus("disguise-processing"), true, { autoHide: false });
          const cover = document.getElementById("fakeCover").files[0];
          const hiddenFiles = Array.from(document.getElementById("fakeInput").files);
          const result = document.getElementById("disguiseResult");
          const skip = document.getElementById("skipEncryption").checked;
          const useAES = !skip && document.getElementById("useAdvancedAES") && document.getElementById("useAdvancedAES").checked;
          const key = skip ? null : (document.getElementById("keyInput").value || null);
          const preview = document.getElementById("disguisePreview");
          result.innerHTML = "";
          preview.innerHTML = "";     

          if (!cover) {
            updateStatus(disguiseStatus, "ËØ∑ÈÄâÊã©Ë°®Èù¢Êñá‰ª∂", false);
            return;
          }
          
          if (hiddenFiles.length === 0) {
            updateStatus(disguiseStatus, "ËØ∑ÈÄâÊã©Ëá≥Â∞ë‰∏Ä‰∏™ÈöêËóèÊñá‰ª∂", false);
            return;
          }
        
          let hiddenName = hiddenFiles.length === 1 ? hiddenFiles[0].name : "ÂêàÈõÜ.zip";
          let hiddenStream;
          let hiddenSize;
        
          if (hiddenFiles.length === 1) {
            hiddenStream = hiddenFiles[0].stream();
            hiddenSize = hiddenFiles[0].size;
          } else {
            const zipBlob = await createZipBlob(hiddenFiles);
            hiddenStream = zipBlob.stream();
            hiddenSize = zipBlob.size;
          }
        
          const originalName = cover.name;
          const ext = originalName.split(".").pop();
          const mime = getExtensionMime(ext);
        
          const marker = new TextEncoder().encode("FAKETAIL");
          const hiddenNameBytes = new TextEncoder().encode(hiddenName);
          const nameLen = new Uint8Array([hiddenNameBytes.length]);
          const isEncrypted = key ? (useAES ? 2 : 1) : 0;
          const encryptedFlag = new Uint8Array([isEncrypted]);
        
          const streams = [];
          streams.push(cover.stream());
          streams.push(new Blob([marker, encryptedFlag, nameLen, hiddenNameBytes]).stream());
        
            if (key) {
              const keyHash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(key));
              const keyHashBytes = new Uint8Array(keyHash).slice(0, 16);
              const keyHashBlob = new Blob([keyHashBytes]);
              streams.push(keyHashBlob.stream());
              if (useAES) {
                const nonce = new Uint8Array(12);
                crypto.getRandomValues(nonce);
                streams.push(new Blob([nonce]).stream());
                hiddenStream = hiddenStream.pipeThrough(createAesCtrTransformStream(key, nonce, true));
              } else {
                hiddenStream = hiddenStream.pipeThrough(createXORTransformStream(key));
              }
            }

          streams.push(hiddenStream);
          
          const fullStream = new ReadableStream({
            async start(controller) {
              for (const stream of streams) {
                const reader = stream.getReader();
                while (true) {
                  const { value, done } = await reader.read();
                  if (done) break;
                  controller.enqueue(value);
                }
              }
              controller.close();
            }
          });

          const markerLen = marker.byteLength;
          const metaLen = 1 + 1 + hiddenNameBytes.length + (key ? 16 + (useAES ? 12 : 0) : 0);
          const totalBytes = (cover.size || 0) + (hiddenSize || 0) + markerLen + metaLen;

          if (btn) setButtonProgress(btn, 0);
            const reader = fullStream.getReader();
            const chunks = [];
            let bytesRead = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              chunks.push(value);

              const byteLen = value && (value.byteLength || value.length || 0);
              bytesRead += byteLen;
              if (totalBytes > 0 && btn) {
                setButtonProgress(btn, Math.min(1, bytesRead / totalBytes));
              }
            }
        
          const restoredBlob = new Blob(chunks, { type: mime });
          const finalBlob = new Blob([restoredBlob], { type: mime });        
          const disguisedFileName = hiddenName.split(".").slice(0, -1).join(".") + "." + (cover.name.split(".").pop() || "bin");          
          const url = URL.createObjectURL(finalBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = disguisedFileName;
          a.textContent = "‰∏ãËΩΩ‰º™Ë£ÖÊñá‰ª∂: " + a.download;
          a.className = "download-link";
          result.appendChild(a);
          saveKeyMapping(disguisedFileName, key);
          updateStatus(disguiseStatus, getRandomStatus("disguise-done"), true);
          renderPreview(preview, mime, url);

          if (btn) clearButtonProgress(btn);
            
        } catch (error) {
          updateStatus(disguiseStatus, "Â§ÑÁêÜÂá∫Èîô: " + (error && error.message ? error.message : String(error)), false);
          const btnErr = document.querySelector('button[onclick="disguiseFile()"]') || document.querySelector('.action-btn');
          if (btnErr) clearButtonProgress(btnErr);
        }
      }
    
      async function restoreFile() {
        const restoreStatus = document.getElementById("restoreStatus");
        const file = document.getElementById("restoreInput").files[0];
        const skip = document.getElementById("skipEncryption").checked;
        const keyInput = document.getElementById("keyInput")?.value || "";
        const btn = document.querySelector('button[onclick="restoreFile()"]') || document.querySelector('.restorebtn[onclick="restoreFile()"]') || document.querySelector('.restorebtn');
        
        if (!file) {
          updateStatus(restoreStatus, "ËØ∑ÈÄâÊã©‰º™Ë£ÖÊñá‰ª∂", false);
          return;
        }
      
        updateStatus(restoreStatus, getRandomStatus("reveal-processing"), true, { autoHide: false });
      
        const preview = document.getElementById("restorePreview");
        preview.innerHTML = "";
      
        try {
          const marker = new TextEncoder().encode("FAKETAIL");
        

          const CHUNK_SIZE = 1024 * 1024;
          const totalSize = file.size;
          let offset = 0;
          let markerIndex = -1;
          let buffer = new Uint8Array();

          if (btn) setButtonProgress(btn, 0);
          while (offset < totalSize) {
            const chunk = new Uint8Array(await file.slice(offset, offset + CHUNK_SIZE).arrayBuffer());
            const combined = new Uint8Array(buffer.length + chunk.length);
            combined.set(buffer);
            combined.set(chunk, buffer.length);

            for (let i = 0; i <= combined.length - marker.length; i++) {
              let match = true;
              for (let j = 0; j < marker.length; j++) {
                if (combined[i + j] !== marker[j]) {
                  match = false;
                  break;
                }
              }
              if (match) {
                markerIndex = offset - buffer.length + i;
                break;
              }
            }
        
            if (markerIndex !== -1) break;

            buffer = chunk.slice(-marker.length);
            offset += CHUNK_SIZE;

            if (btn) setButtonProgress(btn, Math.min(0.98, offset / totalSize));
          }
        
          if (markerIndex === -1) throw new Error("Êú™ÊâæÂà∞Ê†áËÆ∞ÔºåÊó†Ê≥ïËøòÂéü");

          const header = new Uint8Array(await file.slice(markerIndex, markerIndex + 1024).arrayBuffer());
          const isEncrypted = header[marker.length];
          const nameLen = header[marker.length + 1];
          const nameStart = marker.length + 2;
          const nameBytes = header.slice(nameStart, nameStart + nameLen);
          const originalName = new TextDecoder().decode(nameBytes);        
          const ext = originalName.split(".").pop();
          const restoredMime = getExtensionMime(ext);        
          const mimeOffset = nameStart + nameLen;
          const contentStart = markerIndex + mimeOffset;        
          const keyMap = JSON.parse(localStorage.getItem("key_mapping") || "{}");
          const key = keyInput || keyMap[file.name];

          let contentStream = file.slice(contentStart).stream();
          let restoredName = originalName;
          let decryptionFailed = false;
        
          if (isEncrypted) {
            if (skip) {
              decryptionFailed = true;
              restoredName = Math.random().toString(36).substring(2, 10);
            } else {
              const hashBuffer = new Uint8Array(await file.slice(contentStart, contentStart + 16).arrayBuffer());
              const expectedHash = new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(key))).slice(0, 16);
              const isMatch = hashBuffer.every((b, i) => b === expectedHash[i]);
              if (!isMatch) {
                decryptionFailed = true;
                restoredName = Math.random().toString(36).substring(2, 10);
              } else{
                if (isEncrypted === 1) {
                  contentStream = file.slice(contentStart + 16).stream().pipeThrough(createXORTransformStream(key));
                  restoredName = originalName;
                } else if (isEncrypted === 2) {
                  const nonceStart = contentStart + 16;
                  const nonceBuf = new Uint8Array(await file.slice(nonceStart, nonceStart + 12).arrayBuffer());
                  const cipherStart = nonceStart + 12;
                  contentStream = file.slice(cipherStart).stream().pipeThrough(createAesCtrTransformStream(key, nonceBuf, false));
                  restoredName = originalName;
                }
              }
            }
          }
              
          let typedBlob;

          const contentTotal = Math.max(1, totalSize - contentStart);
          const reader = contentStream.getReader();
          const chunks = [];
          let bytesRead = 0;
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            const byteLen = value && (value.byteLength || value.length || 0);
            bytesRead += byteLen;
            if (btn) setButtonProgress(btn, Math.min(1, bytesRead / contentTotal));
          }
          typedBlob = new Blob(chunks, { type: restoredMime });
        
          const url = URL.createObjectURL(typedBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = restoredName;
          a.textContent = (restoredName === originalName ? "‰∏ãËΩΩËøòÂéüÊñá‰ª∂: " : "ÂØÜÈí•ÈîôËØØÔºå‰∏ãËΩΩËß£ÂØÜÂ§±Ë¥•Êï∞ÊçÆ: ") + restoredName;
          a.className = "download-link";
        
          const box = document.getElementById("restoreResult");
          updateStatus(restoreStatus, getRandomStatus("reveal-done"), true);
          box.innerHTML = "";
          box.appendChild(a);

          const preview = document.getElementById("restorePreview");
          preview.innerHTML = "";

          let previewAllowed = true;
          if (decryptionFailed) previewAllowed = false;

          if (previewAllowed) {
            renderPreview(preview, restoredMime, url);
          } else {
            const note = document.createElement('div');
            note.textContent = '';
            note.style.opacity = '0.88';
            note.style.fontSize = '0.95rem';
            preview.appendChild(note);
          }

        if (btn) clearButtonProgress(btn);
      
        } catch (err) {        
          document.getElementById("restoreResult").innerHTML = "";
          document.getElementById("restorePreview").innerHTML = "";
          const isNotDisguised = err.message && err.message.includes("Êú™ÊâæÂà∞Ê†áËÆ∞");
          if (isNotDisguised) {
            updateStatus(restoreStatus, "‰∏çÊòØ‰º™Ë£ÖÊñá‰ª∂", false);
          } else {
            updateStatus(restoreStatus, "Â§ÑÁêÜÂá∫Èîô: " + err.message, false);
          }

          const btnErr = document.querySelector('button[onclick="restoreFile()"]') || document.querySelector('.restorebtn[onclick="restoreFile()"]') || document.querySelector('.restorebtn');
          if (btnErr) clearButtonProgress(btnErr);
        }
      }
    
      const overlayPanel = document.getElementById("overlayPanel");
      const overlayOpacityInput = document.getElementById("overlayOpacityInput");
      const overlayBlurInput = document.getElementById("overlayBlurInput");
      const bgDisplayMode = document.getElementById("bgDisplayMode");
      const modeToggleBtn = document.getElementById("modeToggleBtn");
      const customizeBtn = document.getElementById("customizeBtn");
      const customizePanel = document.getElementById("customizePanel");
      const bgImageInput = document.getElementById("bgImageInput");
      const resetBtn = document.getElementById("resetBtn");
        
      overlayOpacityInput.oninput = () => {
        localStorage.setItem("overlayOpacity", overlayOpacityInput.value);
        overlayPanel.style.opacity = parseInt(overlayOpacityInput.value) / 100;
      };
    
      overlayBlurInput.oninput = () => {
        const blurValue = overlayBlurInput.value;
        overlayPanel.style.backdropFilter = `blur(${blurValue}px)`;
        overlayPanel.style.webkitBackdropFilter = `blur(${blurValue}px)`;
        localStorage.setItem("overlayBlur", blurValue);
      };
    
      async function applyNormalModeSettings() {
        const textColor = localStorage.getItem("textColor") || "#333";
        const bgColor = localStorage.getItem("bgColor") || "#f7f8fc";
        const overlayColor = localStorage.getItem("overlayColor") || "#ffffff";
        const overlayOpacity = localStorage.getItem("overlayOpacity") || "100";
        const overlayBlur = localStorage.getItem("overlayBlur") || "5";
        const bgDisplay = localStorage.getItem("bgDisplay") || "stretch";
      
        overlayPanel.style.backdropFilter = `blur(${overlayBlur}px)`;
        overlayPanel.style.webkitBackdropFilter = `blur(${overlayBlur}px)`;
        document.getElementById("overlayOpacityInput").value = overlayOpacity;
        document.getElementById("overlayOpacityValue").value = overlayOpacity;
        document.getElementById("overlayBlurInput").value = overlayBlur;
        document.getElementById("overlayBlurValue").value = overlayBlur;
      
        const bgImage = await loadBgFromIDB(); 
        if (bgImage) {
          document.body.style.backgroundImage = `url(${bgImage})`;
          document.body.style.backgroundRepeat = (bgDisplay === "repeat") ? "repeat" : "no-repeat";
          if (bgDisplay === "stretch") {
            document.body.style.backgroundSize = "100% 100%";
            document.body.style.backgroundPosition = "center center";
          } else if (bgDisplay === "cover") {
            document.body.style.backgroundSize = "cover";
            document.body.style.backgroundPosition = "center center";
          } else if (bgDisplay === "center") {
            document.body.style.backgroundSize = "auto";
            document.body.style.backgroundPosition = "center";
          }
          overlayPanel.style.display = "block";
        } else {
          document.body.style.backgroundImage = "";
          overlayPanel.style.display = "none";
        }
      
        overlayOpacityInput.value = overlayOpacity;
        overlayBlurInput.value = overlayBlur;
        bgDisplayMode.value = bgDisplay;
      }
    
      async function clearIDB() {
        const db = await openIDB();
        const tx = db.transaction("images", "readwrite");
        tx.objectStore("images").delete("bgImage");
      }
    
      function switchMode(toMode = null) {
        const currentMode = localStorage.getItem("displayMode") || "dark";
        const newMode = toMode || (currentMode === "dark" ? "normal" : "dark");
        document.body.classList.toggle("normal-mode", newMode === "normal");
        localStorage.setItem("displayMode", newMode);
        document.getElementById("modeToggleBtn").textContent = newMode === "normal" ? "üåô" : "üí°";
        document.getElementById("customizeBtn").classList.toggle("hidden", newMode !== "normal");
        document.getElementById("overlayPanel").style.display = newMode === "normal" ? "block" : "none";
      if (newMode === "normal") applyNormalModeSettings();
        else {
          document.body.removeAttribute("style");
          document.querySelectorAll("*:not(#customizePanel):not(#customizePanel *)").forEach(el => {
            el.style.color = "";
          });
        }
      }
    
      function enableDragAndDrop(labelId, inputId) {
        const label = document.getElementById(labelId);
        const input = document.getElementById(inputId);
      
        label.addEventListener("dragover", e => {
          e.preventDefault();
          label.style.background = "rgba(255,255,255,0.35)";
        });
      
        label.addEventListener("dragleave", e => {
          e.preventDefault();
          label.style.background = "";
        });
      
        label.addEventListener("drop", e => {
          e.preventDefault();
          label.style.background = "";
          input.files = e.dataTransfer.files;
        
          const event = new Event("change", { bubbles: true });
          input.dispatchEvent(event);
        });
      }

      function rearrangeElements() {
        const keyPanel = document.getElementById("keyPanel");
        const keysets = document.querySelector(".keysets");
        const headerSection = document.querySelector(".header-section");
          if (window.innerWidth <= 780) {
            if (keyPanel.parentElement === keysets) {
              headerSection.insertBefore(keyPanel, keysets.nextSibling);
            }
          } else {
            if (keyPanel.parentElement !== keysets) {
              keysets.insertBefore(keyPanel, document.getElementById("clearKeyBtn"));
            }
          }
      }    
      rearrangeElements();    
      window.addEventListener("resize", rearrangeElements);

      enableDragAndDrop("coverLabel", "fakeCover");
      enableDragAndDrop("hiddenLabel", "fakeInput");
      enableDragAndDrop("bgLabel", "bgImageInput");
      enableDragAndDrop("restoreLabel", "restoreInput")
            
      bindSliderWithNumber("overlayOpacityInput", "overlayOpacityValue", (val) => {
        localStorage.setItem("overlayOpacity", val);
        applyNormalModeSettings();
      });
      bindSliderWithNumber("overlayBlurInput", "overlayBlurValue", (val) => {
        localStorage.setItem("overlayBlur", val);
        applyNormalModeSettings();
      });

      const pickrInstances = {};
      let isAnyPickrOpen = false;

      function createColorPicker(elId, localStorageKey, applyStyleCallback, defaultColor) {
        const savedColor = localStorage.getItem(localStorageKey) || defaultColor;
        if ((localStorage.getItem("displayMode") || "dark") === "normal") {
          applyStyleCallback(savedColor);
        }
        document.querySelector(elId).style.backgroundColor = savedColor;
      
        const pickr = Pickr.create({
          el: elId,
          theme: "monolith",
          default: savedColor,
          components: {
            preview: true,
            opacity: true,
            hue: true,
            interaction: {
              hex: true,
              rgba: true,
              input: true,
              clear: false,
              save: false
            }
          }
        });
      
        pickr.on("change", (color) => {
          const rgba = color.toRGBA().toString();
          applyStyleCallback(rgba);
          localStorage.setItem(localStorageKey, rgba);
          const buttonEl = pickr.getRoot().button;
          if (buttonEl) buttonEl.style.setProperty('--pcr-color', rgba);
        });
      
        pickrInstances[localStorageKey] = {
          pickr,
          defaultColor,
          elId,
          callback: applyStyleCallback
        };
        pickr.on('show', () => isAnyPickrOpen = true);
        pickr.on('hide', () => isAnyPickrOpen = false);

        return pickr;
      }
    
      modeToggleBtn.onclick = () => switchMode();
      customizeBtn.onclick = () => customizePanel.classList.toggle("hidden");
    
      bgImageInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
          const reader = new FileReader();
        reader.onload = async () => {
          try {
            const base64 = reader.result;
          await saveBgToIDB(base64);
           applyNormalModeSettings(); 
        } catch (e) {
          updateStatus(document.getElementById("clearKeyStatus"), "ÂõæÁâáÂ§™Â§ßÔºåÊó†Ê≥ï‰øùÂ≠òËÉåÊôØÂõæ", false);
        }
      };
      reader.onerror = () => {
        updateStatus(document.getElementById("clearKeyStatus"), "ËØªÂèñÊñá‰ª∂Êó∂Âá∫Èîô", false);
      };
        reader.readAsDataURL(file);
      };
    
      bgDisplayMode.oninput = () => {
        localStorage.setItem("bgDisplay", bgDisplayMode.value);
        applyNormalModeSettings();
      };
    
      document.addEventListener("click", (e) => {
        if (
          !customizePanel.contains(e.target) && 
          !document.getElementById("customizeBtn").contains(e.target) &&
          !isAnyPickrOpen
        ) {
          customizePanel.classList.add("hidden");
        }
      });
    
      document.getElementById("fakeCover").addEventListener("change", function () {
        const span = document.getElementById("coverText");
        span.textContent = this.files.length === 0 ? "ËØ∑ÈÄâÊã©Ë°®Èù¢Êñá‰ª∂" : this.files[0].name;
      });
    
      document.getElementById("fakeInput").addEventListener("change", function () {
        const span = document.getElementById("hiddenText");
        span.textContent =
          this.files.length === 0
            ? "ËØ∑ÈÄâÊã©ÈöêËóèÊñá‰ª∂"
            : this.files.length === 1
            ? this.files[0].name
            : "Â∑≤ÈÄâÊã© " + this.files.length + " ‰∏™Êñá‰ª∂";
      });
    
      document.getElementById("restoreInput").addEventListener("change", function () {
        const span = document.getElementById("restoreText");
        span.textContent = this.files.length === 0 ? "ËØ∑ÈÄâÊã©‰º™Ë£ÖÊñá‰ª∂" : this.files[0].name;
      });
    
      document.getElementById("bgImageInput").addEventListener("change", function () {
        const fileName = this.files[0].name;
        document.getElementById("bgText").textContent = "ÂΩìÂâçËÉåÊôØ:" + fileName;
        localStorage.setItem("bgImageName", fileName); 
      });
    
      document.getElementById("resetBtn").onclick = () => {
        if (confirm("Á°ÆÂÆöË¶ÅËøòÂéüÈªòËÆ§Â§ñËßÇËÆæÁΩÆÂêóÔºü")) {
          localStorage.removeItem("textColor");
          localStorage.removeItem("bgColor");
          localStorage.removeItem("bgImage");
          localStorage.removeItem("overlayColor");
          localStorage.removeItem("overlayOpacity");
          localStorage.removeItem("bgDisplay");
          localStorage.removeItem("overlayBlur");
          localStorage.removeItem("bgImageName");
          document.getElementById("bgImageInput").value = "";
          document.getElementById("bgText").textContent = "ÈÄâÊã©ËÉåÊôØÂõæ";
          for (const key in pickrInstances) {
            const { pickr, defaultColor, elId, callback } = pickrInstances[key];
            pickr.setColor(defaultColor);
            localStorage.setItem(key, defaultColor);
            callback(defaultColor);
          }
          clearIDB();
          applyNormalModeSettings();
        }
      };

      (function () {
        const ANNOTATIONS = [
          { selector: '.title-section', title: 'Âä†ÂØÜÈÄâÈ°π', text: 'È¶ñÊ¨°ÂêØÂä®Êó∂Ë∑≥ËøáÂä†ÂØÜÈªòËÆ§ÂêØÁî®„ÄÇÂä†ÂØÜ‰ºöÊèêÂçáÊñá‰ª∂ÂÆâÂÖ®ÊÄßÂπ∂Áï•ÂæÆÈôç‰ΩéÊñá‰ª∂Â§ÑÁêÜÈÄüÂ∫¶„ÄÇÈ´òÁ∫ßÂä†ÂØÜÁöÑÂÆâÂÖ®ÊÄßÊõ¥È´òÔºåÂ§ÑÁêÜÈÄüÂ∫¶ËæÉÂ∏∏ËßÑÂä†ÂØÜÁ®çÊÖ¢‰ΩÜÂ∑ÆË∑ù‰∏çÊòæËëó„ÄÇ', highlightSelector: "#keycfg", highlightDuration: 'persistent'},
          { selector: '.card', title: 'ÂäüËÉΩÂå∫', text: 'Â∏ÆÂä©ÊñáÊú¨', highlightDuration: 'persistent' },
          { selector: '#modeToggleBtn', title: 'Â§ñËßÇÂàáÊç¢', text: 'ÁÇπÂáªÂèØÂú®Ê≠£Â∏∏Ê®°Âºè‰∏éÈªëÂ§úÊ®°Âºè‰πãÈó¥ÂàáÊç¢„ÄÇ‰ªÖÊ≠£Â∏∏Ê®°ÂºèÊîØÊåÅÂ§ñËßÇËá™ÂÆö‰πâ„ÄÇ', highlightDuration: 'persistent'}
        ];

        const helpBtn = document.getElementById('helpBtn');
        const helpOverlay = document.getElementById('helpOverlay');
        let tipEntries = [];
        let closeHandler = null;
        let repositionObserver = null;
        let isPositioning = false;
        let resizeDebounce = null;
        let mutationDebounce = null;

        function buildTips() {
          tipEntries.forEach(t => {
            if (t.tipEl && t.tipEl.parentNode) t.tipEl.parentNode.removeChild(t.tipEl);
            if (t.highlightEl && t.highlightEl.parentNode) t.highlightEl.parentNode.removeChild(t.highlightEl);
            if (t.highlightTimer) clearTimeout(t.highlightTimer);
          });
          tipEntries = [];

          ANNOTATIONS.forEach((ann) => {
            const nodes = Array.from(document.querySelectorAll(ann.selector));
            if (!nodes.length) return;
            nodes.forEach((node, idx) => {
              const tip = document.createElement('div');
              tip.className = 'help-tip';

              const title = document.createElement('h3');
              const titleText = (node.dataset && node.dataset.helpTitle) ? node.dataset.helpTitle : (ann.title + (nodes.length > 1 ? ` ${idx + 1}` : ''));
              title.textContent = titleText;
              const p = document.createElement('p');
              const textContent = (node.dataset && node.dataset.helpText) ? node.dataset.helpText : ann.text;
              p.textContent = textContent;
              tip.appendChild(title);
              tip.appendChild(p);
              document.body.appendChild(tip);


              const highlightSpec = node.dataset && node.dataset.helpHighlight ? node.dataset.helpHighlight : (ann.highlightSelector ? ann.highlightSelector : null);
              const durationAttr = (node.dataset && node.dataset.helpHighlightDuration) ? node.dataset.helpHighlightDuration : (ann.highlightDuration !== undefined ? String(ann.highlightDuration) : null);
              let highlightDuration = null;
              if (durationAttr) {
                const da = String(durationAttr).trim().toLowerCase();
                if (da === 'persistent' || da === 'stay' || da === 'infinite' || da === '0') {
                  highlightDuration = 'persistent';
                } else {
                  const n = parseInt(da, 10);
                  if (!isNaN(n) && n > 0) highlightDuration = n;
                }
              }
              tipEntries.push({ targetEl: node, tipEl: tip, highlightSpec: highlightSpec, highlightDuration: highlightDuration, highlightEl: null, highlightTimer: null });
            });
          });
        }

        function positionTips() {

          if (isPositioning) return;
          isPositioning = true;

          window.requestAnimationFrame(() => {
            try {

              if (repositionObserver) {
                try { repositionObserver.disconnect(); } catch (e) {}
              }

              tipEntries.forEach((entry) => {
                const { targetEl, tipEl } = entry;

                if (!document.body.contains(targetEl)) {
                  if (tipEl && tipEl.parentNode) tipEl.parentNode.removeChild(tipEl);
                  return;
                }

                const rect = targetEl.getBoundingClientRect();
                tipEl.style.opacity = '0';
                tipEl.style.left = '0px';
                tipEl.style.top = '0px';

                const tipRect = tipEl.getBoundingClientRect();

                let tipLeft = rect.left + (rect.width - tipRect.width) / 2;

                let tipTop = rect.top + (rect.height - tipRect.height) / 2;


                if (tipTop < 8) {
                  tipTop = rect.bottom + 4;
                }

                const viewportW = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                if (tipLeft < 8) tipLeft = 8;
                if (tipLeft + tipRect.width > viewportW - 8) tipLeft = Math.max(8, viewportW - tipRect.width - 8);

                tipEl.style.left = (tipLeft) + 'px';
                tipEl.style.top = (tipTop) + 'px';
                tipEl.style.opacity = '1';
                tipEl.style.transform = 'translateY(0) scale(1)';

                if (entry.highlightEl) {
                  updateHighlightPosition(entry);
                }
              });

              updateHighlights();
            } catch (err) {
            } finally {

              setTimeout(() => {
                if (helpOverlay.style.display === 'block') {
                  if (!repositionObserver) {
                    repositionObserver = new MutationObserver(mutationHandler);
                  }
                  try {
                    repositionObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
                  } catch (e) {}
                }
                isPositioning = false;
              }, 40);
            }
          });
        }

        function updateHighlightPosition(entry) {
          if (!entry || !entry.highlightEl) return;
          let highlightTarget = null;
          if (entry.highlightSpec) {
            try { highlightTarget = document.querySelector(entry.highlightSpec); } catch (e) { highlightTarget = null; }
          }
          if (!highlightTarget) highlightTarget = entry.targetEl;
          if (!highlightTarget || !document.body.contains(highlightTarget)) return;

          const r = highlightTarget.getBoundingClientRect();
          const prev = entry._lastHLRect;
          const needUpdate = !prev || prev.left !== Math.round(r.left) || prev.top !== Math.round(r.top) || prev.width !== Math.round(r.width) || prev.height !== Math.round(r.height);
          if (!needUpdate) return;

          entry._lastHLRect = { left: Math.round(r.left), top: Math.round(r.top), width: Math.round(r.width), height: Math.round(r.height) };
          const hl = entry.highlightEl;
          hl.style.left = r.left + 'px';
          hl.style.top = r.top + 'px';
          hl.style.width = r.width + 'px';
          hl.style.height = r.height + 'px';
        }

        function updateHighlights() {
          for (const entry of tipEntries) {
            if (entry.highlightEl) updateHighlightPosition(entry);
          }
        }

        let highlightLoopId = null;
        function highlightLoop() {
          updateHighlights();
          highlightLoopId = requestAnimationFrame(highlightLoop);
        }
        function startHighlightLoop() {
          if (highlightLoopId !== null) return;
          highlightLoopId = requestAnimationFrame(highlightLoop);
        }
        function stopHighlightLoop() {
          if (highlightLoopId !== null) {
            cancelAnimationFrame(highlightLoopId);
            highlightLoopId = null;
          }
        }

        function createHighlightForEntry(entry) {
          let highlightTarget = null;
          if (entry.highlightSpec) {
            try { highlightTarget = document.querySelector(entry.highlightSpec); } catch (e) { highlightTarget = null; }
          }
          if (!highlightTarget) highlightTarget = entry.targetEl;

          if (!highlightTarget || !document.body.contains(highlightTarget)) return;

          const rect = highlightTarget.getBoundingClientRect();
          const hl = document.createElement('div');
          hl.className = 'help-highlight';
          hl.style.left = rect.left + 'px';
          hl.style.top = rect.top + 'px';
          hl.style.width = rect.width + 'px';
          hl.style.height = rect.height + 'px';
          hl.style.opacity = '0';
          hl.style.transform = 'scale(0.98)';
          document.body.appendChild(hl);

          const initRect = highlightTarget.getBoundingClientRect();
          entry._lastHLRect = { left: Math.round(initRect.left), top: Math.round(initRect.top), width: Math.round(initRect.width), height: Math.round(initRect.height) };


          requestAnimationFrame(() => {
            hl.style.transition = 'opacity 300ms ease, transform 300ms ease';
            hl.style.opacity = '1';
            hl.style.transform = 'scale(1)';
          });

          const dur = (entry.highlightDuration === 'persistent') ? 'persistent' : (typeof entry.highlightDuration === 'number' ? entry.highlightDuration : 1200);

          if (dur === 'persistent') {
            entry.highlightEl = hl;
            entry.highlightTimer = null;
            return;
          }
          const t = setTimeout(() => {
            try {
              hl.style.opacity = '0';
              hl.style.transform = 'scale(1.02)';
              setTimeout(() => { if (hl && hl.parentNode) hl.parentNode.removeChild(hl); }, 350);
            } catch (e) {}
          }, dur);

          entry.highlightEl = hl;
          entry.highlightTimer = t;
        }

        function mutationHandler(mutations) {
          let relevant = false;
          for (const m of mutations) {
            const target = m.target;

            if (target && target.closest && (target.closest('.help-tip') || target.closest('.help-highlight'))) continue;
            relevant = true;
            break;
          }
          if (!relevant) return;

          if (mutationDebounce) clearTimeout(mutationDebounce);
          mutationDebounce = setTimeout(positionTips, 80);
        }

        function openHelp() {
          buildTips();
          helpOverlay.style.display = 'block';
          helpOverlay.setAttribute('aria-hidden', 'false');

          positionTips();

          requestAnimationFrame(() => {
            tipEntries.forEach((entry) => createHighlightForEntry(entry));
          });

          window.addEventListener('resize', () => {
            if (resizeDebounce) clearTimeout(resizeDebounce);
            resizeDebounce = setTimeout(positionTips, 80);
          });
          window.addEventListener('scroll', () => {
            if (resizeDebounce) clearTimeout(resizeDebounce);
            resizeDebounce = setTimeout(positionTips, 80);
          }, true);

          if (!repositionObserver) {
            repositionObserver = new MutationObserver(mutationHandler);
          }

          try {
            repositionObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
          } catch (e) {}

          setTimeout(() => {
            closeHandler = () => closeHelp();
            document.addEventListener('click', closeHandler);
          }, 0);
        }

        function closeHelp() {

          tipEntries.forEach(t => {
            if (t.tipEl && t.tipEl.parentNode) t.tipEl.parentNode.removeChild(t.tipEl);
            if (t.highlightEl && t.highlightEl.parentNode) t.highlightEl.parentNode.removeChild(t.highlightEl);
            if (t.highlightTimer) clearTimeout(t.highlightTimer);
          });
          tipEntries = [];
          helpOverlay.style.display = 'none';
          helpOverlay.setAttribute('aria-hidden', 'true');

          window.removeEventListener('resize', positionTips);
          window.removeEventListener('scroll', positionTips, true);
          if (repositionObserver) {
            try { repositionObserver.disconnect(); } catch (e) {}
            repositionObserver = null;
          }
          if (closeHandler) {
            document.removeEventListener('click', closeHandler);
            closeHandler = null;
          }
          if (resizeDebounce) { clearTimeout(resizeDebounce); resizeDebounce = null; }
          if (mutationDebounce) { clearTimeout(mutationDebounce); mutationDebounce = null; }
        }

        helpBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const isOpen = helpOverlay.style.display === 'block';
          if (isOpen) {
            closeHelp();
          } else {
            openHelp();
          }
        });

        const customizeBtn = document.getElementById('customizeBtn');
        const helpIconBtn = document.getElementById('helpBtn');
        function triggerAnimation(el, cls) {
          if (!el) return;
          el.classList.remove(cls);
          void el.offsetWidth;
          el.classList.add(cls);
          const onEnd = () => { el.classList.remove(cls); el.removeEventListener('animationend', onEnd); };
          el.addEventListener('animationend', onEnd);
        }
        if (customizeBtn) {
          customizeBtn.addEventListener('click', (e) => {
            triggerAnimation(customizeBtn, 'rotate-center');
          });
        }
        if (helpIconBtn) {
          helpIconBtn.addEventListener('click', (e) => {
            triggerAnimation(helpIconBtn, 'rotate-bottom');
          });
        }

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && helpOverlay.style.display === 'block') closeHelp();
        });

        window.addEventListener('orientationchange', () => { if (helpOverlay.style.display === 'block') positionTips(); });
      })();
    
      window.addEventListener("DOMContentLoaded", async () => {
        await loadLibrary("zip");
        await loadLibrary("pickr");
        await loadLibrary("pickrCSS", true);
        const savedMode = localStorage.getItem("displayMode") || "dark";
        switchMode(savedMode);
        const savedBgName = localStorage.getItem("bgImageName");
        if (savedBgName) {
          document.getElementById("bgText").textContent = "ÂΩìÂâçËÉåÊôØ:" + savedBgName;
        }

        createColorPicker("#textColorInput", "textColor", (val) => {
          document.body.style.color = val;
        }, "rgba(56,56,56,1)");
      
        createColorPicker("#bgColorInput", "bgColor", (val) => {
          document.body.style.backgroundColor = val;
        }, "rgba(255,255,255,1)");
      
        createColorPicker("#overlayColorInput", "overlayColor", (val) => {
          document.getElementById("overlayPanel").style.backgroundColor = val;
        }, "rgba(255,255,255,0)");        
      
        const skipCheckbox = document.getElementById("skipEncryption");
        const aesCheckbox = document.getElementById("useAdvancedAES");
        const clearBtn = document.getElementById("clearKeyBtn");
        const keyPanel = document.getElementById("keyPanel");
        const button = document.querySelector("button[onclick='toggleKey()']");      
        const keyPanelOpen = localStorage.getItem("keyPanelOpen") === "true";      
        if (keyPanelOpen) {
          clearBtn.classList.remove("hidden");
          keyPanel.classList.remove("hidden");
        } else {
          clearBtn.classList.add("hidden");
          keyPanel.classList.add("hidden");
        }
        const isHidden = keyPanel.classList.contains("hidden");
        button.textContent = isHidden ? "Âä†ÂØÜÂ§ÑÁêÜÈÖçÁΩÆ" : "ÈöêËóèÂä†ÂØÜÈÖçÁΩÆ";
        skipCheckbox.checked = localStorage.getItem("skipEncryption") === "true";
        aesCheckbox.checked = localStorage.getItem("useAdvancedAES") === "true";
        skipCheckbox.addEventListener("change", () => {
        localStorage.setItem("skipEncryption", skipCheckbox.checked);
        });
        aesCheckbox.addEventListener("change", () => {
          localStorage.setItem("useAdvancedAES", aesCheckbox.checked);
        });
      });

        function _resolveBtn(elOrId) {
          if (typeof elOrId === 'string') return document.getElementById(elOrId);
          return elOrId;
        }

        function setButtonProgress(btnOrId, fraction) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          const f = Math.max(0, Math.min(1, Number(fraction) || 0));
          btn.classList.add('progressing');
          btn.classList.remove('indeterminate', 'finished');
          btn.style.setProperty('--progress', (f * 100) + '%');
          btn.setAttribute('aria-valuemin', '0');
          btn.setAttribute('aria-valuemax', '100');
          btn.setAttribute('aria-valuenow', Math.round(f * 100));
        }

        function startIndeterminate(btnOrId) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          btn.classList.add('indeterminate');
          btn.classList.add('progressing');
          btn.style.setProperty('--progress', '35%');
        }

        function clearButtonProgress(btnOrId) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          btn.classList.add('finished');
          setTimeout(() => {
            btn.classList.remove('progressing', 'indeterminate', 'finished');
            btn.style.setProperty('--progress', '0%');
            btn.removeAttribute('aria-valuenow');
          }, 260);
        }
    </script>
  </div>
</body>
</html>
