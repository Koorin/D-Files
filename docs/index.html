<!--
    D-Files 文件易容
    
    Copyright 2025 Koorin

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-->
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="assets/magicat.png" sizes="32x32">
  <title>文件易容 D-Files</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background-color: #2e3344;
      color: #f7f8fc;
      padding: 2rem;
      margin: auto;
      line-height: 1.6;
      position: relative;
      z-index: 1;
      background-attachment: fixed;
    }

    .container {
      max-width: 1280px;
      margin: 0 auto;
      padding: 1rem;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
    }

    input[type="file"] {
      width:180px;
      font-size: 1rem;
      color: inherit;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 0.5rem 1rem;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    input[type="file"]::file-selector-button {
      background-color: transparent;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 0;
      font: inherit;
    }
    input[type="file"]:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }

    .action-btn , .restorebtn{
      padding: 0.665rem 1.888rem;
      font-size: 1rem;
      border-radius: 0.375rem;
      background-color: #6366f1;
      color: white;
      border: none;
      cursor: pointer;
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .uniButton {
      background-color: #6366f1;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 1rem;
    }
    .uniButton:hover , .fakebtn:hover , .action-btn:hover , .restorebtn:hover {
      background-color: #4f46e5;
    }
    
    .download-link {
      display: inline-block;
      margin-top: 0.95rem;
      color: #2563eb;
      text-decoration: none;
      white-space: normal;
      word-break: break-all;
    }
    .hidden {
      display: none !important;
    }
    .preview {
      margin-top: 1rem;
      max-height: 100%;
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    body.normal-mode {
      background-color: #f7f8fc;
      color: #333333;
    }

    #modeToggleBtn, #customizeBtn , #helpBtn{
      display: inline-block;
      font-size: 2rem;
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 50%;
      cursor: pointer;
      position: fixed;
      z-index: 1000;
      text-shadow: 0px 0px 1rem rgba(0, 0, 0, 0.8); 
    }
    #modeToggleBtn {
      top: 0;
      right: 8px;
    }
    #customizeBtn {
      top: 50px;
      right: 5px;
    }
    #helpBtn {
      top: 2px;
      right: 50px;
    }
    #modeToggleBtn:hover, #customizeBtn:hover, #helpBtn:hover {
      transform: scale(1.2);
      transition: all 0.3s ease;
    }

    #overlayPanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      pointer-events: none;
      background-color: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: background-color 0.3s, opacity 0.3s, filter 0.3s;
      display: none;
    }
    #customizePanel {
      position: fixed;
      top: 4rem;
      right: 80px;
      max-height: 80vh;
      width:360px;
      overflow-y: auto;
      background: rgba(144, 151, 172, 0.1);
      padding: 1rem;
      border-radius: 0.5rem;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 999;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      transition: max-height 0.3s ease;
    }
    #resetBtn {
      position: relative;
      margin: 0;
    }
    
    .status-indicator {
      display: inline-block;
      margin-left: 10px;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      background-color: #6366f1;
      color: white;
      opacity: 0;
      transition: opacity 0.3s ease;
      vertical-align: middle;
    }
    .status-indicator.active {
      opacity: 1;
    }
    .status-indicator.success {
      background-color: #10b981;
    }
    .status-indicator.error {
      background-color: #ef4444;
    }
    .status-indicator.warning {
      background-color: #f59e0b;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      margin-bottom: 0.75rem;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="range"] {
      flex: 1;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.3);
      cursor:pointer;
      min-width: 50px;
      outline: none;
      transition: background 0.3s;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      cursor: pointer;
      border: none;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .slider-group input[type="number"] {
      width: 60px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: inherit;
      border-radius: 4px;
      min-width: 10px;
      text-align: center;
      padding: 2px 6px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .color-group {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .semi-transparent-input {
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      padding: 10px 12px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      border-radius: 6px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .transelect {
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      padding: 6px 8px;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .ekinput {
      text-align: center;
      height: 38px;
      width: 130px;
      background-color: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: none;
      border-radius: 6px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }

    .custom-file-btn {
      display: inline-block;
      padding: 0.5rem 0.8rem;
      border-radius: 6px;
      font-size: 0.95rem;
      white-space: normal;
      word-break: break-all;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      color: inherit;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .custom-file-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }
    .bgbtn {
      display:block;
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      font-size: 0.95rem;
      text-align: center;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.3s, border 0.3s;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .bgbtn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: #6366f1;
    }

    .fileRow {
      margin-top: 0.5rem;
    }
    h1 , p {
      margin: 0.5rem;
    }
    p{
      margin-bottom: 1rem;
    }
    h2 {
      margin-top: 0;    
      border-bottom: 1px solid rgba(255,255,255,0.2);
      padding-bottom: 0.5rem;
    }

    .fakebtn {
      padding: 0.5rem 0.5rem;
      border-radius: 6px;
      font-size: 0.95rem;
      cursor: pointer;
      color: white;
      background: #6366f1;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .fakebtn:hover {
      background: #4f46e5;
    }
    .nobtn {
      display: none;
    }
    .fakebtn:has(.nobtn:checked) {
      background-color: #2b21e7;
      padding: 0.5rem 0.5rem;
    }
    .fakebtn:has(.nobtn:checked):hover {
      background-color: #1d15b3;
    }
    .btnlabel {
      border-radius: 4px;
      user-select: none;
    }
    .keysets {
      display: flex;
      position: relative;
      align-items: center;
      gap: 0.4rem;
      min-height: 1rem;
    }
    #keyPanel {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      box-sizing: border-box;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      flex: 1;
      min-width: 380px;
      display: table;
    }
    .card2 {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .title-section {
      display: flex;
      justify-content: center;
    }
    .header-section {
      display: grid;
      justify-content: center;
      text-align: center;
      width: 1280px;
      box-sizing: border-box;
      min-width: 380px;
      margin-bottom: 1rem;
      padding: 1rem;
      background: rgba(255,255,255,0.1);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    @media (max-width: 600px), (max-height: 450px) {
      #customizePanel {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        max-height: none;
        border-radius: 0;
        overflow-y: auto;
        box-shadow: none;
        box-sizing: border-box; 
      }
      .bgbtn {
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        max-height: none;
        border-radius: 0;
        overflow-y: auto;
        padding: 1rem;
        box-shadow: none;
        box-sizing: border-box; 
      }
      #modeToggleBtn, #customizeBtn, #helpBtn{
        font-size: medium;
        }
      #modeToggleBtn {
        top: 3px;
        right: 5px;
      }
      #customizeBtn {
        top: 30px;
        right: 4px;
        }
      #helpBtn {
        top: 4px;
        right: 30px;
      }
      #modeToggleBtn:hover, #customizeBtn:hover {
        background: none;
        backdrop-filter:unset;
        -webkit-backdrop-filter: unset;
      }
      .action-btn:hover , .restorebtn:hover {
        background-color: #6366f1;
      }
      .color-group {
        margin-top: 2.5rem;
      }
      .container {
        padding: 0.8rem;
      }
      .header-section {
        width: 100%;
        min-width: auto;
        padding: 1.25rem;
        box-sizing: border-box;
        text-align: center;
      }
      .keysets {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
      }
      .keysets .uniButton, #clearKeyBtn {
        width: 200px;
        max-width: 90%;
        box-sizing: border-box;
      }
      #keyPanel {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.45rem;
        width: 100%;
        margin-top: 0.5rem;
      }
      .ekinput {
        width: 160px;
        max-width: 90%;
      }
      .card2 {
        display: flex;
        gap: 1rem;
        align-items: stretch;
      }
      .card {
        min-width: auto;
        width: 100%;
        box-sizing: border-box;
      }
      h1 { 
        font-size: 1.6rem; 
      }
      p  { 
        font-size: 0.95rem; margin-bottom: .75rem; 
      }
      .custom-file-btn {
        width: 220px;
        max-width: 90%;
        text-align: center;
      }
      .preview, .download-link {
        max-width: 100%;
      }
      .help-tip { max-width: 92vw; font-size: 0.95rem; }
    }

    .progress-btn{
      position: relative;
      overflow: hidden;
      --progress: 0%;
      transition: color .15s linear;
    }

    .progress-btn .label{
      position: relative;
      z-index: 3;
      pointer-events: none;
    }

    .progress-btn::before{
      content: "";
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: var(--progress);
      z-index: 1;
      pointer-events: none;
      background: linear-gradient(90deg, rgba(95,77,255,0.95) 0%, rgba(80,65,240,0.95) 100%);
      mix-blend-mode: normal;
      transition: width 120ms linear;
      opacity: 0.98;
    }

    .progress-btn.progressing .label{
      z-index: 4;
    }

    @keyframes indeterminate-slide {
      0%   { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }

    @keyframes spin-center {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    @keyframes spin-bottom {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }

    .rotate-center {
      transform-origin: center center !important;
      animation: spin-center 700ms cubic-bezier(.2,.9,.2,1);
    }

    .rotate-bottom {
      transform-origin: center bottom !important;
      animation: spin-bottom 700ms cubic-bezier(.2,.9,.2,1);
    }
    .progress-btn.indeterminate::before{
      width: 35%;
      left: -35%;
      background: linear-gradient(90deg, rgba(95,77,255,0.95), rgba(120,100,255,0.95));
      transition: none;
      animation: indeterminate-slide 1.1s linear infinite;
    }

    .progress-btn.finished::before{
      transition: opacity 240ms ease, width 240ms ease;
      opacity: 0;
    }
    #helpOverlay {
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 2000;
      display: none;
      pointer-events: auto;
    }

    .help-tip {
      position: fixed;
      max-width: 340px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      z-index: 2010;
      font-size: 0.95rem;
      line-height: 1.3;
      transform-origin: center top;
      transition: transform 160ms ease, opacity 160ms ease;
      pointer-events: auto;
      backdrop-filter: blur(4px);
    }
  
    .help-tip h3 { margin: 0 0 6px 0; font-size: 1rem; color: #fff; }
    .help-tip p { margin: 0; font-size: 0.92rem; color: rgba(255,255,255,0.92); }

    .help-highlight {
      position: fixed;
      border-radius: 6px;
      box-shadow: 0 1px 24px rgb(255, 254, 210), 0 0 0 3px rgba(255, 254, 210, 0.8) inset;
      z-index: 2005; 
      pointer-events: none;
      transition: opacity 300ms ease, transform 300ms ease;
      opacity: 0;
    }

  </style>
</head>
<body>
  <div class="container">
    <div id="overlayPanel"></div>
      <button id="modeToggleBtn" title="切换显示模式">💡</button>
      <button id="customizeBtn" class="hidden" title="外观设置">⚙️</button>
      <button id="helpBtn" title="查看帮助">❓</button>
      <div id="helpOverlay" aria-hidden="true"></div>
    <div id="customizePanel" class="hidden">
      <div class="color-group">
        <label>文字颜色</label>
        <div id="textColorInput"></div>
        <label>背景色</label>
        <div id="bgColorInput"></div>
        <label>前景色</label>
        <div id="overlayColorInput"></div>
      </div>

      <div class="slider-group">
        <label for ="overlayOpacityInput">透明度</label>
        <input type="range" id="overlayOpacityInput" min="0" max="100" value="100">
        <input type="number" id="overlayOpacityValue" min="0" max="100" value="100">
      </div>
      <div class="slider-group">
        <label for = "overlayBlurInput">模糊度</label>
        <input type="range" id="overlayBlurInput" min="0" max="100" value="5">
        <input type="number" id="overlayBlurValue" min="0" max="100" value="5">
      </div>
      <div class="fileRow">
        <label class="bgbtn" id="bgLabel">
          <span id="bgText">选择背景图</span>
          <input type="file" id="bgImageInput" accept="image/*" hidden>
        </label>
      </div>
      <div class="semi-transparent-input">
        <label>背景图显示方式：
          <select id="bgDisplayMode" class="transelect">
            <option value="stretch">拉伸</option>
            <option value="cover">填充</option>
            <option value="repeat">平铺</option>
            <option value="center">居中</option>
          </select>
        </label>
        <button id="resetBtn" class="uniButton">还原默认值</button>
      </div>
      
    </div>
    <div class="title-section">
    <div class="header-section">
      <h1>🤔 文件易容 ☝🏻🤓</h1>
      <p>╮（￣▽￣）╭ 可将任意文件变成其他文件，也可提取被隐藏的原文件。</p>
        <div class="keysets">
          <button id="keycfg" class="uniButton" onclick="toggleKey()">加密处理配置</button>
            <div id="keyPanel" class="hidden">
              <label class="fakebtn"><input type="checkbox" id="useAdvancedAES" class="nobtn"><span class="btnlabel">高级加密</span></label>
              <input type="text" id="keyInput" class="ekinput" placeholder="输入密钥（可选）">
              <label class="fakebtn"><input type="checkbox" id="skipEncryption" class="nobtn"><span class="btnlabel">跳过加密</span></label>
            </div>
          <button id="clearKeyBtn" class="uniButton" onclick="clearKeyMapping()">清空本地密钥记忆</button>
          <span id="clearKeyStatus" class="status-indicator"></span>
        </div>
    </div>
    </div>

    <div class="card2">
      <div class="card" data-help-title="生成伪装文件" data-help-text="表面文件：隐藏文件改头换面后的样子。生成后的伪装文件除大小外无论外观还是功能性均与表面文件完全一致。可一次性将复数文件自动打包并伪装为一个文件。用密钥加密生成文件时，会自动记忆生成文件名的对应密钥。">
        <h2>生成伪装文件</h2>
        <div class="fileRow">
          <label class="custom-file-btn" id="coverLabel">
            <span id="coverText">请选择表面文件</span>
            <input type="file" id="fakeCover" hidden>
          </label>
        </div>
  
        <div class="fileRow">
          <label class="custom-file-btn" id="hiddenLabel">
            <span id="hiddenText">请选择隐藏文件</span>
            <input type="file" id="fakeInput" multiple hidden>
          </label>
        </div>      
        <button class="action-btn progress-btn" onclick="disguiseFile()"><span class="label">😎 Disguise Ready</span></button><span id="disguiseStatus" class="status-indicator"></span>
        <div id="disguiseResult"></div>
        <div id="disguisePreview"></div>
      </div>

      <div class="card" data-help-title="还原伪装文件" data-help-text="当跳过加密未启用时，会尝试匹配生成过的文件对应密钥。还原成功时，自动展示可预览的文件。密钥错误还原失败时只能提取出无效文件。">
        <h2>还原伪装文件</h2>
          <div class="fileRow">
            <label class="custom-file-btn" id="restoreLabel">
            <span id="restoreText">请选择伪装文件</span>
            <input type="file" id="restoreInput" hidden>
            </label>
          </div>      
        <button class="restorebtn progress-btn" onclick="restoreFile()"><span class="label">🤠👐揭开他们的面纱</span></button><span id="restoreStatus" class="status-indicator"></span>
        <div id="restoreResult"></div>
        <div id="restorePreview"></div>
      </div>
    </div>
    
    <script>
    
      function executeCodeSafely(code, name) {
        const script = document.createElement('script');
        script.textContent = `//# sourceURL=${name}_cache.js\n${code}`;
        document.head.appendChild(script).remove();
      }

      const LIBRARY_URLS = {
        zip: "https://cdn.jsdelivr.net/npm/@zip.js/zip.js/dist/zip.min.js",
        pickr: "https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js",
        pickrCSS: "https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/monolith.min.css"
      };
      const CACHE_KEYS = {
        zip: "cachedZipJS",
        pickr: "cachedPickrJS",
        pickrCSS: "cachedPickrCSS"
      };
      async function loadLibrary(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        const cached = localStorage.getItem(key);      
        if (cached) {
          try {
            if (isCSS) {
              injectStyle(cached);
            } else {
              executeCodeSafely(cached, name);
            }
          } catch (e) {
            await fetchAndCacheLibrary(name, isCSS);
          }
          tryUpdateLibraryInBackground(name, isCSS);
        } else {
          await fetchAndCacheLibrary(name, isCSS);
        }
      }
      async function fetchAndCacheLibrary(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        try {
          const response = await fetch(url, { cache: "no-store" });
          const code = await response.text();
          localStorage.setItem(key, code);
          if (isCSS) {
            injectStyle(code);
          } else {
            executeCodeSafely(code, name);
          }
        } catch (err) {
          alert(`${name} 加载失败，且无本地缓存，功能不可用`);
          throw err;
        }
      }
      async function tryUpdateLibraryInBackground(name, isCSS = false) {
        const key = CACHE_KEYS[name];
        const url = LIBRARY_URLS[name];
        try {
          const response = await fetch(url, { cache: "no-store" });
          const code = await response.text();
          localStorage.setItem(key, code);
        } catch (err) {
        }
      }
      function injectStyle(cssCode) {
        const style = document.createElement("style");
        style.textContent = cssCode;
        document.head.appendChild(style);
      }
    
      function getRandomStatus(type) {
        const random = Math.random();
      
        if (type === "disguise-processing") {
          if (random < 0.3) {
            const phrases = [
              "少女祈祷中...",
              "No time to waste😡",
              "少女折寿中Σ(っ °Д °;)っ" ,
              "Now you see me, soon you won't",
              "A really big fxxking hole coming right up!",
              "oiiaioooooiai"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "处理中...";
        }

        if (type === "disguise-done") {
          if (random < 0.3) {
            const phrases = [
              "正在偷吃电弧星！",
              "S属性大爆发！Share!",
              "豆浆~",
              "El Psy Kongroo"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "处理完成！";
        }
      
        if (type === "reveal-processing") {
          if (random < 0.3) { 
            const phrases = [
               "🤠👐面纱后面藏着什么呢？",
               "🎵正在治疗自己🎶",
               "If you want it,then you have to take it",
               "oiiaioooooiai",
               "Open Sesame!"
            ];
            return phrases[Math.floor(Math.random() * phrases.length)];
          }
          return "处理中...";
        }
      
        if (type === "reveal-done") {
          if (random < 0.3) {
            const phrases = [
              "🤠👐伟大的揭幕表演！", 
              "是我喜欢的内容，直接拿来。",
              "El Psy Kongroo"
            ];
          return phrases[Math.floor(Math.random() * phrases.length)];
          }      
          return "处理完成";
        }
      }    

      function bindSliderWithNumber(sliderId, numberId, onChange) {
        const slider = document.getElementById(sliderId);
        const number = document.getElementById(numberId);
        slider.addEventListener("input", () => {
          number.value = slider.value;
          if (onChange) onChange(slider.value);
        });
        number.addEventListener("input", () => {
          slider.value = number.value;
          if (onChange) onChange(slider.value);
        });
      }
    
      function updateStatus(element, text, ok = null, options = {}) {
        if (!element) return;

        const cfg = {
          autoHide: options.autoHide === undefined ? true : Boolean(options.autoHide),
          delay: typeof options.delay === 'number' ? options.delay : 2000
        };

        if (element._statusTimeout) {
          clearTimeout(element._statusTimeout);
          element._statusTimeout = null;
        }

        if (!text) {
          element.textContent = "";
          element.classList.remove("active");
          element.classList.remove(
            "status-ok", "status-success", "ok", "success",
            "status-fail", "status-error", "fail", "error",
            "status-warning", "warning", "warn"
          );
          return;
        }
      
        element.textContent = text;
        element.classList.add("active");
        element.classList.remove(
          "status-ok", "status-success", "ok", "success",
          "status-fail", "status-error", "fail", "error",
          "status-warning", "warning", "warn"
        );
      
        if (ok === true) {
          element.classList.add("status-ok", "status-success", "ok", "success");
        } else if (ok === false) {
          element.classList.add("status-fail", "status-error", "fail", "error");
        } else if (ok === "warning" || ok === "warn") {
          element.classList.add("status-warning", "warning", "warn");
        }

        const isProcessingText = text === "处理中...";
        if (cfg.autoHide && !isProcessingText) {
          element._statusTimeout = setTimeout(() => {
            element.classList.remove("active");
            element._statusTimeout = null;
          }, cfg.delay);
        }
      }
    
      function clearKeyMapping() {
        localStorage.removeItem("key_mapping");
        updateStatus(document.getElementById("clearKeyStatus"), "密钥配置已清除", true);
      }
    
      function toggleKey() {
        const clearBtn = document.getElementById("clearKeyBtn");
        const keyPanel = document.getElementById("keyPanel");
        const toggleBtn = event.target;
        clearBtn.classList.toggle("hidden");
        keyPanel.classList.toggle("hidden");
        const isNowVisible = !clearBtn.classList.contains("hidden");
        toggleBtn.textContent = isNowVisible ? "隐藏加密配置" : "加密处理配置";
        localStorage.setItem("keyPanelOpen", isNowVisible ? "true" : "false");
      }

      function renderPreview(container, mime, url) {
        container.innerHTML = "";
        if (!mime || !url) return;
      
        if (mime.startsWith("image/")) {
          const el = document.createElement("img");
          el.src = url; el.className = "preview";
          container.appendChild(el);
          return;
        }
        if (mime.startsWith("audio/")) {
          const el = document.createElement("audio");
          el.controls = true; el.src = url; container.appendChild(el); return;
        }
        if (mime.startsWith("video/")) {
          const el = document.createElement("video");
          el.controls = true; el.src = url; el.className = "preview"; container.appendChild(el); return;
        }
        if (mime === "application/pdf") {
          const el = document.createElement("iframe");
          el.src = url; el.className = "preview"; container.appendChild(el); return;
        }
        if (mime.startsWith("text/") || mime === "application/json" || mime === "application/javascript" || mime === "text/csv") {
          fetch(url).then(res => res.text()).then(text => {
            const pre = document.createElement("pre");
            pre.textContent = text;
            container.appendChild(pre);
          }).catch(()=> {
            const note = document.createElement("div");
            note.textContent = "文本读取失败。";
            container.appendChild(note);
          });
          return;
        }
      
        const note = document.createElement("div");
        note.textContent = "该文件类型暂不支持在线预览。";
        container.appendChild(note);
      }
    
      function createXORTransformStream(key) {
        const encoder = new TextEncoder();
        const keyBytes = encoder.encode(key);
        return new TransformStream({
          transform(chunk, controller) {
            const output = new Uint8Array(chunk.length);
            for (let i = 0; i < chunk.length; i++) {
              output[i] = chunk[i] ^ keyBytes[i % keyBytes.length];
            }
            controller.enqueue(output);
          }
        });
      }
    
    function createAesCtrTransformStream(password, nonce, isEncrypt) {
      const BLOCK_SIZE = 24 * 1024;
      const keyPromise = (async () => {
        const pwBytes = new TextEncoder().encode(password);
        const hash = await crypto.subtle.digest('SHA-256', pwBytes);
        return crypto.subtle.importKey("raw", hash, { name: "AES-CTR" }, false, ["encrypt", "decrypt"]);
      })();

      let globalBlockCounter = 0;

      function makeCounterForBlock(blockCounter) {
        const counter = new Uint8Array(16);
        counter.set(nonce, 0);
        const view = new DataView(counter.buffer);
        view.setUint32(12, blockCounter, false);
        return counter;
      }

      return new TransformStream({
        async transform(chunk, controller) {
          const key = await keyPromise;
          const uint8Chunk = chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk);

          let offset = 0;
          while (offset < uint8Chunk.length) {
            const slice = uint8Chunk.subarray(offset, offset + BLOCK_SIZE);

            const startBlockIndex = globalBlockCounter;
            const counter = makeCounterForBlock(startBlockIndex);
            const algo = { name: "AES-CTR", counter: counter, length: 128 };
            const processedBuffer = await crypto.subtle[isEncrypt ? "encrypt" : "decrypt"](algo, key, slice);
            const processed = new Uint8Array(processedBuffer);
            controller.enqueue(processed);
            const blocksProcessed = Math.ceil(slice.length / 16);
            globalBlockCounter += blocksProcessed;
            offset += slice.length;
          }
        }
      });
    }
    
      async function createZipBlob(files) {
            const writer = new zip.ZipWriter(new zip.BlobWriter("application/zip"));
            for (const file of files) {
              await writer.add(file.name, new zip.BlobReader(file));
            }
            return await writer.close();
      }
      
      function getExtensionMime(ext) {
        const mimes = {
          jpg: "image/jpeg",
          jpeg: "image/jpeg",
          png: "image/png",
          apng: "image/apng",
          gif: "image/gif",
          webp: "image/webp",
          bmp: "image/bmp",
          ico: "image/x-icon",
          mp3: "audio/mpeg",
          aac: "audio/aac",
          wav: "audio/wav",
          flac: "audio/flac",
          ogg: "audio/ogg",
          mp4: "video/mp4",
          webm: "video/webm",
          pdf: "application/pdf",
          txt: "text/plain",
          json: "application/json",
          js: "application/javascript",
          csv: "text/csv",
          html: "text/html"
        };
        return mimes[ext.toLowerCase()] || "application/octet-stream";
      }
    
      function saveKeyMapping(filename, key) {
        if (!key) return;
        let existingMap = {};
        try {
          existingMap = JSON.parse(localStorage.getItem("key_mapping") || "{}");
        } catch (e) {}
        existingMap[filename] = key;
        localStorage.setItem("key_mapping", JSON.stringify(existingMap));
      }
    
      function openIDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open("bgStore", 1);
          request.onupgradeneeded = () => {
            const db = request.result;
            db.createObjectStore("images");
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
    
      async function saveBgToIDB(dataURL) {
        const db = await openIDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("images", "readwrite");
          const store = tx.objectStore("images");
          const request = store.put(dataURL, "bgImage");
        
          request.onsuccess = () => {
            tx.oncomplete = () => {
              resolve();
            };
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
    
      async function loadBgFromIDB() {
        const db = await openIDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction("images", "readonly");
          const store = tx.objectStore("images");
          const request = store.get("bgImage");
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
      
      async function disguiseFile() {
        const disguiseStatus = document.getElementById("disguiseStatus");
        const btn = document.querySelector('button[onclick="disguiseFile()"]') || document.querySelector('.action-btn');
        try {
          updateStatus(disguiseStatus, getRandomStatus("disguise-processing"), true, { autoHide: false });
          const cover = document.getElementById("fakeCover").files[0];
          const hiddenFiles = Array.from(document.getElementById("fakeInput").files);
          const result = document.getElementById("disguiseResult");
          const skip = document.getElementById("skipEncryption").checked;
          const useAES = !skip && document.getElementById("useAdvancedAES") && document.getElementById("useAdvancedAES").checked;
          const key = skip ? null : (document.getElementById("keyInput").value || null);
          const preview = document.getElementById("disguisePreview");
          result.innerHTML = "";
          preview.innerHTML = "";     

          if (!cover) {
            updateStatus(disguiseStatus, "请选择表面文件", false);
            return;
          }
          
          if (hiddenFiles.length === 0) {
            updateStatus(disguiseStatus, "请选择至少一个隐藏文件", false);
            return;
          }
        
          let hiddenName = hiddenFiles.length === 1 ? hiddenFiles[0].name : "合集.zip";
          let hiddenStream;
          let hiddenSize;
        
          if (hiddenFiles.length === 1) {
            hiddenStream = hiddenFiles[0].stream();
            hiddenSize = hiddenFiles[0].size;
          } else {
            const zipBlob = await createZipBlob(hiddenFiles);
            hiddenStream = zipBlob.stream();
            hiddenSize = zipBlob.size;
          }
        
          const originalName = cover.name;
          const ext = originalName.split(".").pop();
          const mime = getExtensionMime(ext);
        
          const marker = new TextEncoder().encode("FAKETAIL");
          const hiddenNameBytes = new TextEncoder().encode(hiddenName);
          const nameLen = new Uint8Array([hiddenNameBytes.length]);
          const isEncrypted = key ? (useAES ? 2 : 1) : 0;
          const encryptedFlag = new Uint8Array([isEncrypted]);
        
          const streams = [];
          streams.push(cover.stream());
          streams.push(new Blob([marker, encryptedFlag, nameLen, hiddenNameBytes]).stream());
        
            if (key) {
              const keyHash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(key));
              const keyHashBytes = new Uint8Array(keyHash).slice(0, 16);
              const keyHashBlob = new Blob([keyHashBytes]);
              streams.push(keyHashBlob.stream());
              if (useAES) {
                const nonce = new Uint8Array(12);
                crypto.getRandomValues(nonce);
                streams.push(new Blob([nonce]).stream());
                hiddenStream = hiddenStream.pipeThrough(createAesCtrTransformStream(key, nonce, true));
              } else {
                hiddenStream = hiddenStream.pipeThrough(createXORTransformStream(key));
              }
            }

          streams.push(hiddenStream);
          
          const fullStream = new ReadableStream({
            async start(controller) {
              for (const stream of streams) {
                const reader = stream.getReader();
                while (true) {
                  const { value, done } = await reader.read();
                  if (done) break;
                  controller.enqueue(value);
                }
              }
              controller.close();
            }
          });

          const markerLen = marker.byteLength;
          const metaLen = 1 + 1 + hiddenNameBytes.length + (key ? 16 + (useAES ? 12 : 0) : 0);
          const totalBytes = (cover.size || 0) + (hiddenSize || 0) + markerLen + metaLen;

          if (btn) setButtonProgress(btn, 0);
            const reader = fullStream.getReader();
            const chunks = [];
            let bytesRead = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              chunks.push(value);

              const byteLen = value && (value.byteLength || value.length || 0);
              bytesRead += byteLen;
              if (totalBytes > 0 && btn) {
                setButtonProgress(btn, Math.min(1, bytesRead / totalBytes));
              }
            }
        
          const restoredBlob = new Blob(chunks, { type: mime });
          const finalBlob = new Blob([restoredBlob], { type: mime });        
          const disguisedFileName = hiddenName.split(".").slice(0, -1).join(".") + "." + (cover.name.split(".").pop() || "bin");          
          const url = URL.createObjectURL(finalBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = disguisedFileName;
          a.textContent = "下载伪装文件: " + a.download;
          a.className = "download-link";
          result.appendChild(a);
          saveKeyMapping(disguisedFileName, key);
          updateStatus(disguiseStatus, getRandomStatus("disguise-done"), true);
          renderPreview(preview, mime, url);

          if (btn) clearButtonProgress(btn);
            
        } catch (error) {
          updateStatus(disguiseStatus, "处理出错: " + (error && error.message ? error.message : String(error)), false);
          const btnErr = document.querySelector('button[onclick="disguiseFile()"]') || document.querySelector('.action-btn');
          if (btnErr) clearButtonProgress(btnErr);
        }
      }
    
      async function restoreFile() {
        const restoreStatus = document.getElementById("restoreStatus");
        const file = document.getElementById("restoreInput").files[0];
        const skip = document.getElementById("skipEncryption").checked;
        const keyInput = document.getElementById("keyInput")?.value || "";
        const btn = document.querySelector('button[onclick="restoreFile()"]') || document.querySelector('.restorebtn[onclick="restoreFile()"]') || document.querySelector('.restorebtn');
        
        if (!file) {
          updateStatus(restoreStatus, "请选择伪装文件", false);
          return;
        }
      
        updateStatus(restoreStatus, getRandomStatus("reveal-processing"), true, { autoHide: false });
      
        const preview = document.getElementById("restorePreview");
        preview.innerHTML = "";
      
        try {
          const marker = new TextEncoder().encode("FAKETAIL");
        

          const CHUNK_SIZE = 1024 * 1024;
          const totalSize = file.size;
          let offset = 0;
          let markerIndex = -1;
          let buffer = new Uint8Array();

          if (btn) setButtonProgress(btn, 0);
          while (offset < totalSize) {
            const chunk = new Uint8Array(await file.slice(offset, offset + CHUNK_SIZE).arrayBuffer());
            const combined = new Uint8Array(buffer.length + chunk.length);
            combined.set(buffer);
            combined.set(chunk, buffer.length);

            for (let i = 0; i <= combined.length - marker.length; i++) {
              let match = true;
              for (let j = 0; j < marker.length; j++) {
                if (combined[i + j] !== marker[j]) {
                  match = false;
                  break;
                }
              }
              if (match) {
                markerIndex = offset - buffer.length + i;
                break;
              }
            }
        
            if (markerIndex !== -1) break;

            buffer = chunk.slice(-marker.length);
            offset += CHUNK_SIZE;

            if (btn) setButtonProgress(btn, Math.min(0.98, offset / totalSize));
          }
        
          if (markerIndex === -1) throw new Error("未找到标记，无法还原");

          const header = new Uint8Array(await file.slice(markerIndex, markerIndex + 1024).arrayBuffer());
          const isEncrypted = header[marker.length];
          const nameLen = header[marker.length + 1];
          const nameStart = marker.length + 2;
          const nameBytes = header.slice(nameStart, nameStart + nameLen);
          const originalName = new TextDecoder().decode(nameBytes);        
          const ext = originalName.split(".").pop();
          const restoredMime = getExtensionMime(ext);        
          const mimeOffset = nameStart + nameLen;
          const contentStart = markerIndex + mimeOffset;        
          const keyMap = JSON.parse(localStorage.getItem("key_mapping") || "{}");
          const key = keyInput || keyMap[file.name];

          let contentStream = file.slice(contentStart).stream();
          let restoredName = originalName;
          let decryptionFailed = false;
        
          if (isEncrypted) {
            if (skip) {
              decryptionFailed = true;
              restoredName = Math.random().toString(36).substring(2, 10);
            } else {
              const hashBuffer = new Uint8Array(await file.slice(contentStart, contentStart + 16).arrayBuffer());
              const expectedHash = new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(key))).slice(0, 16);
              const isMatch = hashBuffer.every((b, i) => b === expectedHash[i]);
              if (!isMatch) {
                decryptionFailed = true;
                restoredName = Math.random().toString(36).substring(2, 10);
              } else{
                if (isEncrypted === 1) {
                  contentStream = file.slice(contentStart + 16).stream().pipeThrough(createXORTransformStream(key));
                  restoredName = originalName;
                } else if (isEncrypted === 2) {
                  const nonceStart = contentStart + 16;
                  const nonceBuf = new Uint8Array(await file.slice(nonceStart, nonceStart + 12).arrayBuffer());
                  const cipherStart = nonceStart + 12;
                  contentStream = file.slice(cipherStart).stream().pipeThrough(createAesCtrTransformStream(key, nonceBuf, false));
                  restoredName = originalName;
                }
              }
            }
          }
              
          let typedBlob;

          const contentTotal = Math.max(1, totalSize - contentStart);
          const reader = contentStream.getReader();
          const chunks = [];
          let bytesRead = 0;
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            const byteLen = value && (value.byteLength || value.length || 0);
            bytesRead += byteLen;
            if (btn) setButtonProgress(btn, Math.min(1, bytesRead / contentTotal));
          }
          typedBlob = new Blob(chunks, { type: restoredMime });
        
          const url = URL.createObjectURL(typedBlob);
          const a = document.createElement("a");
          a.href = url;
          a.download = restoredName;
          a.textContent = (restoredName === originalName ? "下载还原文件: " : "密钥错误，下载解密失败数据: ") + restoredName;
          a.className = "download-link";
        
          const box = document.getElementById("restoreResult");
          updateStatus(restoreStatus, getRandomStatus("reveal-done"), true);
          box.innerHTML = "";
          box.appendChild(a);

          const preview = document.getElementById("restorePreview");
          preview.innerHTML = "";

          let previewAllowed = true;
          if (decryptionFailed) previewAllowed = false;

          if (previewAllowed) {
            renderPreview(preview, restoredMime, url);
          } else {
            const note = document.createElement('div');
            note.textContent = '';
            note.style.opacity = '0.88';
            note.style.fontSize = '0.95rem';
            preview.appendChild(note);
          }

        if (btn) clearButtonProgress(btn);
      
        } catch (err) {        
          document.getElementById("restoreResult").innerHTML = "";
          document.getElementById("restorePreview").innerHTML = "";
          const isNotDisguised = err.message && err.message.includes("未找到标记");
          if (isNotDisguised) {
            updateStatus(restoreStatus, "不是伪装文件", false);
          } else {
            updateStatus(restoreStatus, "处理出错: " + err.message, false);
          }

          const btnErr = document.querySelector('button[onclick="restoreFile()"]') || document.querySelector('.restorebtn[onclick="restoreFile()"]') || document.querySelector('.restorebtn');
          if (btnErr) clearButtonProgress(btnErr);
        }
      }
    
      const overlayPanel = document.getElementById("overlayPanel");
      const overlayOpacityInput = document.getElementById("overlayOpacityInput");
      const overlayBlurInput = document.getElementById("overlayBlurInput");
      const bgDisplayMode = document.getElementById("bgDisplayMode");
      const modeToggleBtn = document.getElementById("modeToggleBtn");
      const customizeBtn = document.getElementById("customizeBtn");
      const customizePanel = document.getElementById("customizePanel");
      const bgImageInput = document.getElementById("bgImageInput");
      const resetBtn = document.getElementById("resetBtn");
        
      overlayOpacityInput.oninput = () => {
        localStorage.setItem("overlayOpacity", overlayOpacityInput.value);
        overlayPanel.style.opacity = parseInt(overlayOpacityInput.value) / 100;
      };
    
      overlayBlurInput.oninput = () => {
        const blurValue = overlayBlurInput.value;
        overlayPanel.style.backdropFilter = `blur(${blurValue}px)`;
        overlayPanel.style.webkitBackdropFilter = `blur(${blurValue}px)`;
        localStorage.setItem("overlayBlur", blurValue);
      };
    
      async function applyNormalModeSettings() {
        const textColor = localStorage.getItem("textColor") || "#333";
        const bgColor = localStorage.getItem("bgColor") || "#f7f8fc";
        const overlayColor = localStorage.getItem("overlayColor") || "#ffffff";
        const overlayOpacity = localStorage.getItem("overlayOpacity") || "100";
        const overlayBlur = localStorage.getItem("overlayBlur") || "5";
        const bgDisplay = localStorage.getItem("bgDisplay") || "stretch";
      
        overlayPanel.style.backdropFilter = `blur(${overlayBlur}px)`;
        overlayPanel.style.webkitBackdropFilter = `blur(${overlayBlur}px)`;
        document.getElementById("overlayOpacityInput").value = overlayOpacity;
        document.getElementById("overlayOpacityValue").value = overlayOpacity;
        document.getElementById("overlayBlurInput").value = overlayBlur;
        document.getElementById("overlayBlurValue").value = overlayBlur;
      
        const bgImage = await loadBgFromIDB(); 
        if (bgImage) {
          document.body.style.backgroundImage = `url(${bgImage})`;
          document.body.style.backgroundRepeat = (bgDisplay === "repeat") ? "repeat" : "no-repeat";
          if (bgDisplay === "stretch") {
            document.body.style.backgroundSize = "100% 100%";
            document.body.style.backgroundPosition = "center center";
          } else if (bgDisplay === "cover") {
            document.body.style.backgroundSize = "cover";
            document.body.style.backgroundPosition = "center center";
          } else if (bgDisplay === "center") {
            document.body.style.backgroundSize = "auto";
            document.body.style.backgroundPosition = "center";
          }
          overlayPanel.style.display = "block";
        } else {
          document.body.style.backgroundImage = "";
          overlayPanel.style.display = "none";
        }
      
        overlayOpacityInput.value = overlayOpacity;
        overlayBlurInput.value = overlayBlur;
        bgDisplayMode.value = bgDisplay;
      }
    
      async function clearIDB() {
        const db = await openIDB();
        const tx = db.transaction("images", "readwrite");
        tx.objectStore("images").delete("bgImage");
      }
    
      function switchMode(toMode = null) {
        const currentMode = localStorage.getItem("displayMode") || "dark";
        const newMode = toMode || (currentMode === "dark" ? "normal" : "dark");
        document.body.classList.toggle("normal-mode", newMode === "normal");
        localStorage.setItem("displayMode", newMode);
        document.getElementById("modeToggleBtn").textContent = newMode === "normal" ? "🌙" : "💡";
        document.getElementById("customizeBtn").classList.toggle("hidden", newMode !== "normal");
        document.getElementById("overlayPanel").style.display = newMode === "normal" ? "block" : "none";
      if (newMode === "normal") applyNormalModeSettings();
        else {
          document.body.removeAttribute("style");
          document.querySelectorAll("*:not(#customizePanel):not(#customizePanel *)").forEach(el => {
            el.style.color = "";
          });
        }
      }
    
      function enableDragAndDrop(labelId, inputId) {
        const label = document.getElementById(labelId);
        const input = document.getElementById(inputId);
      
        label.addEventListener("dragover", e => {
          e.preventDefault();
          label.style.background = "rgba(255,255,255,0.35)";
        });
      
        label.addEventListener("dragleave", e => {
          e.preventDefault();
          label.style.background = "";
        });
      
        label.addEventListener("drop", e => {
          e.preventDefault();
          label.style.background = "";
          input.files = e.dataTransfer.files;
        
          const event = new Event("change", { bubbles: true });
          input.dispatchEvent(event);
        });
      }

      function rearrangeElements() {
        const keyPanel = document.getElementById("keyPanel");
        const keysets = document.querySelector(".keysets");
        const headerSection = document.querySelector(".header-section");
          if (window.innerWidth <= 780) {
            if (keyPanel.parentElement === keysets) {
              headerSection.insertBefore(keyPanel, keysets.nextSibling);
            }
          } else {
            if (keyPanel.parentElement !== keysets) {
              keysets.insertBefore(keyPanel, document.getElementById("clearKeyBtn"));
            }
          }
      }    
      rearrangeElements();    
      window.addEventListener("resize", rearrangeElements);

      enableDragAndDrop("coverLabel", "fakeCover");
      enableDragAndDrop("hiddenLabel", "fakeInput");
      enableDragAndDrop("bgLabel", "bgImageInput");
      enableDragAndDrop("restoreLabel", "restoreInput")
            
      bindSliderWithNumber("overlayOpacityInput", "overlayOpacityValue", (val) => {
        localStorage.setItem("overlayOpacity", val);
        applyNormalModeSettings();
      });
      bindSliderWithNumber("overlayBlurInput", "overlayBlurValue", (val) => {
        localStorage.setItem("overlayBlur", val);
        applyNormalModeSettings();
      });

      const pickrInstances = {};
      let isAnyPickrOpen = false;

      function createColorPicker(elId, localStorageKey, applyStyleCallback, defaultColor) {
        const savedColor = localStorage.getItem(localStorageKey) || defaultColor;
        if ((localStorage.getItem("displayMode") || "dark") === "normal") {
          applyStyleCallback(savedColor);
        }
        document.querySelector(elId).style.backgroundColor = savedColor;
      
        const pickr = Pickr.create({
          el: elId,
          theme: "monolith",
          default: savedColor,
          components: {
            preview: true,
            opacity: true,
            hue: true,
            interaction: {
              hex: true,
              rgba: true,
              input: true,
              clear: false,
              save: false
            }
          }
        });
      
        pickr.on("change", (color) => {
          const rgba = color.toRGBA().toString();
          applyStyleCallback(rgba);
          localStorage.setItem(localStorageKey, rgba);
          const buttonEl = pickr.getRoot().button;
          if (buttonEl) buttonEl.style.setProperty('--pcr-color', rgba);
        });
      
        pickrInstances[localStorageKey] = {
          pickr,
          defaultColor,
          elId,
          callback: applyStyleCallback
        };
        pickr.on('show', () => isAnyPickrOpen = true);
        pickr.on('hide', () => isAnyPickrOpen = false);

        return pickr;
      }
    
      modeToggleBtn.onclick = () => switchMode();
      customizeBtn.onclick = () => customizePanel.classList.toggle("hidden");
    
      bgImageInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
          const reader = new FileReader();
        reader.onload = async () => {
          try {
            const base64 = reader.result;
          await saveBgToIDB(base64);
           applyNormalModeSettings(); 
        } catch (e) {
          updateStatus(document.getElementById("clearKeyStatus"), "图片太大，无法保存背景图", false);
        }
      };
      reader.onerror = () => {
        updateStatus(document.getElementById("clearKeyStatus"), "读取文件时出错", false);
      };
        reader.readAsDataURL(file);
      };
    
      bgDisplayMode.oninput = () => {
        localStorage.setItem("bgDisplay", bgDisplayMode.value);
        applyNormalModeSettings();
      };
    
      document.addEventListener("click", (e) => {
        if (
          !customizePanel.contains(e.target) && 
          !document.getElementById("customizeBtn").contains(e.target) &&
          !isAnyPickrOpen
        ) {
          customizePanel.classList.add("hidden");
        }
      });
    
      document.getElementById("fakeCover").addEventListener("change", function () {
        const span = document.getElementById("coverText");
        span.textContent = this.files.length === 0 ? "请选择表面文件" : this.files[0].name;
      });
    
      document.getElementById("fakeInput").addEventListener("change", function () {
        const span = document.getElementById("hiddenText");
        span.textContent =
          this.files.length === 0
            ? "请选择隐藏文件"
            : this.files.length === 1
            ? this.files[0].name
            : "已选择 " + this.files.length + " 个文件";
      });
    
      document.getElementById("restoreInput").addEventListener("change", function () {
        const span = document.getElementById("restoreText");
        span.textContent = this.files.length === 0 ? "请选择伪装文件" : this.files[0].name;
      });
    
      document.getElementById("bgImageInput").addEventListener("change", function () {
        const fileName = this.files[0].name;
        document.getElementById("bgText").textContent = "当前背景:" + fileName;
        localStorage.setItem("bgImageName", fileName); 
      });
    
      document.getElementById("resetBtn").onclick = () => {
        if (confirm("确定要还原默认外观设置吗？")) {
          localStorage.removeItem("textColor");
          localStorage.removeItem("bgColor");
          localStorage.removeItem("bgImage");
          localStorage.removeItem("overlayColor");
          localStorage.removeItem("overlayOpacity");
          localStorage.removeItem("bgDisplay");
          localStorage.removeItem("overlayBlur");
          localStorage.removeItem("bgImageName");
          document.getElementById("bgImageInput").value = "";
          document.getElementById("bgText").textContent = "选择背景图";
          for (const key in pickrInstances) {
            const { pickr, defaultColor, elId, callback } = pickrInstances[key];
            pickr.setColor(defaultColor);
            localStorage.setItem(key, defaultColor);
            callback(defaultColor);
          }
          clearIDB();
          applyNormalModeSettings();
        }
      };

      (function () {
        const ANNOTATIONS = [
          { selector: '.title-section', title: '加密选项', text: '首次启动时跳过加密默认启用。加密会提升文件安全性并略微降低文件处理速度。高级加密的安全性更高，处理速度较常规加密稍慢但差距不显著。', highlightSelector: "#keycfg", highlightDuration: 'persistent'},
          { selector: '.card', title: '功能区', text: '帮助文本', highlightDuration: 'persistent' },
          { selector: '#modeToggleBtn', title: '外观切换', text: '点击可在正常模式与黑夜模式之间切换。仅正常模式支持外观自定义。', highlightDuration: 'persistent'}
        ];

        const helpBtn = document.getElementById('helpBtn');
        const helpOverlay = document.getElementById('helpOverlay');
        let tipEntries = [];
        let closeHandler = null;
        let repositionObserver = null;
        let isPositioning = false;
        let resizeDebounce = null;
        let mutationDebounce = null;

        function buildTips() {
          tipEntries.forEach(t => {
            if (t.tipEl && t.tipEl.parentNode) t.tipEl.parentNode.removeChild(t.tipEl);
            if (t.highlightEl && t.highlightEl.parentNode) t.highlightEl.parentNode.removeChild(t.highlightEl);
            if (t.highlightTimer) clearTimeout(t.highlightTimer);
          });
          tipEntries = [];

          ANNOTATIONS.forEach((ann) => {
            const nodes = Array.from(document.querySelectorAll(ann.selector));
            if (!nodes.length) return;
            nodes.forEach((node, idx) => {
              const tip = document.createElement('div');
              tip.className = 'help-tip';

              const title = document.createElement('h3');
              const titleText = (node.dataset && node.dataset.helpTitle) ? node.dataset.helpTitle : (ann.title + (nodes.length > 1 ? ` ${idx + 1}` : ''));
              title.textContent = titleText;
              const p = document.createElement('p');
              const textContent = (node.dataset && node.dataset.helpText) ? node.dataset.helpText : ann.text;
              p.textContent = textContent;
              tip.appendChild(title);
              tip.appendChild(p);
              document.body.appendChild(tip);


              const highlightSpec = node.dataset && node.dataset.helpHighlight ? node.dataset.helpHighlight : (ann.highlightSelector ? ann.highlightSelector : null);
              const durationAttr = (node.dataset && node.dataset.helpHighlightDuration) ? node.dataset.helpHighlightDuration : (ann.highlightDuration !== undefined ? String(ann.highlightDuration) : null);
              let highlightDuration = null;
              if (durationAttr) {
                const da = String(durationAttr).trim().toLowerCase();
                if (da === 'persistent' || da === 'stay' || da === 'infinite' || da === '0') {
                  highlightDuration = 'persistent';
                } else {
                  const n = parseInt(da, 10);
                  if (!isNaN(n) && n > 0) highlightDuration = n;
                }
              }
              tipEntries.push({ targetEl: node, tipEl: tip, highlightSpec: highlightSpec, highlightDuration: highlightDuration, highlightEl: null, highlightTimer: null });
            });
          });
        }

        function positionTips() {

          if (isPositioning) return;
          isPositioning = true;

          window.requestAnimationFrame(() => {
            try {

              if (repositionObserver) {
                try { repositionObserver.disconnect(); } catch (e) {}
              }

              tipEntries.forEach((entry) => {
                const { targetEl, tipEl } = entry;

                if (!document.body.contains(targetEl)) {
                  if (tipEl && tipEl.parentNode) tipEl.parentNode.removeChild(tipEl);
                  return;
                }

                const rect = targetEl.getBoundingClientRect();
                tipEl.style.opacity = '0';
                tipEl.style.left = '0px';
                tipEl.style.top = '0px';

                const tipRect = tipEl.getBoundingClientRect();

                let tipLeft = rect.left + (rect.width - tipRect.width) / 2;

                let tipTop = rect.top + (rect.height - tipRect.height) / 2;


                if (tipTop < 8) {
                  tipTop = rect.bottom + 4;
                }

                const viewportW = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
                if (tipLeft < 8) tipLeft = 8;
                if (tipLeft + tipRect.width > viewportW - 8) tipLeft = Math.max(8, viewportW - tipRect.width - 8);

                tipEl.style.left = (tipLeft) + 'px';
                tipEl.style.top = (tipTop) + 'px';
                tipEl.style.opacity = '1';
                tipEl.style.transform = 'translateY(0) scale(1)';

                if (entry.highlightEl) {
                  updateHighlightPosition(entry);
                }
              });

              updateHighlights();
            } catch (err) {
            } finally {

              setTimeout(() => {
                if (helpOverlay.style.display === 'block') {
                  if (!repositionObserver) {
                    repositionObserver = new MutationObserver(mutationHandler);
                  }
                  try {
                    repositionObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
                  } catch (e) {}
                }
                isPositioning = false;
              }, 40);
            }
          });
        }

        function updateHighlightPosition(entry) {
          if (!entry || !entry.highlightEl) return;
          let highlightTarget = null;
          if (entry.highlightSpec) {
            try { highlightTarget = document.querySelector(entry.highlightSpec); } catch (e) { highlightTarget = null; }
          }
          if (!highlightTarget) highlightTarget = entry.targetEl;
          if (!highlightTarget || !document.body.contains(highlightTarget)) return;

          const r = highlightTarget.getBoundingClientRect();
          const prev = entry._lastHLRect;
          const needUpdate = !prev || prev.left !== Math.round(r.left) || prev.top !== Math.round(r.top) || prev.width !== Math.round(r.width) || prev.height !== Math.round(r.height);
          if (!needUpdate) return;

          entry._lastHLRect = { left: Math.round(r.left), top: Math.round(r.top), width: Math.round(r.width), height: Math.round(r.height) };
          const hl = entry.highlightEl;
          hl.style.left = r.left + 'px';
          hl.style.top = r.top + 'px';
          hl.style.width = r.width + 'px';
          hl.style.height = r.height + 'px';
        }

        function updateHighlights() {
          for (const entry of tipEntries) {
            if (entry.highlightEl) updateHighlightPosition(entry);
          }
        }

        let highlightLoopId = null;
        function highlightLoop() {
          updateHighlights();
          highlightLoopId = requestAnimationFrame(highlightLoop);
        }
        function startHighlightLoop() {
          if (highlightLoopId !== null) return;
          highlightLoopId = requestAnimationFrame(highlightLoop);
        }
        function stopHighlightLoop() {
          if (highlightLoopId !== null) {
            cancelAnimationFrame(highlightLoopId);
            highlightLoopId = null;
          }
        }

        function createHighlightForEntry(entry) {
          let highlightTarget = null;
          if (entry.highlightSpec) {
            try { highlightTarget = document.querySelector(entry.highlightSpec); } catch (e) { highlightTarget = null; }
          }
          if (!highlightTarget) highlightTarget = entry.targetEl;

          if (!highlightTarget || !document.body.contains(highlightTarget)) return;

          const rect = highlightTarget.getBoundingClientRect();
          const hl = document.createElement('div');
          hl.className = 'help-highlight';
          hl.style.left = rect.left + 'px';
          hl.style.top = rect.top + 'px';
          hl.style.width = rect.width + 'px';
          hl.style.height = rect.height + 'px';
          hl.style.opacity = '0';
          hl.style.transform = 'scale(0.98)';
          document.body.appendChild(hl);

          const initRect = highlightTarget.getBoundingClientRect();
          entry._lastHLRect = { left: Math.round(initRect.left), top: Math.round(initRect.top), width: Math.round(initRect.width), height: Math.round(initRect.height) };


          requestAnimationFrame(() => {
            hl.style.transition = 'opacity 300ms ease, transform 300ms ease';
            hl.style.opacity = '1';
            hl.style.transform = 'scale(1)';
          });

          const dur = (entry.highlightDuration === 'persistent') ? 'persistent' : (typeof entry.highlightDuration === 'number' ? entry.highlightDuration : 1200);

          if (dur === 'persistent') {
            entry.highlightEl = hl;
            entry.highlightTimer = null;
            return;
          }
          const t = setTimeout(() => {
            try {
              hl.style.opacity = '0';
              hl.style.transform = 'scale(1.02)';
              setTimeout(() => { if (hl && hl.parentNode) hl.parentNode.removeChild(hl); }, 350);
            } catch (e) {}
          }, dur);

          entry.highlightEl = hl;
          entry.highlightTimer = t;
        }

        function mutationHandler(mutations) {
          let relevant = false;
          for (const m of mutations) {
            const target = m.target;

            if (target && target.closest && (target.closest('.help-tip') || target.closest('.help-highlight'))) continue;
            relevant = true;
            break;
          }
          if (!relevant) return;

          if (mutationDebounce) clearTimeout(mutationDebounce);
          mutationDebounce = setTimeout(positionTips, 80);
        }

        function openHelp() {
          buildTips();
          helpOverlay.style.display = 'block';
          helpOverlay.setAttribute('aria-hidden', 'false');

          positionTips();

          requestAnimationFrame(() => {
            tipEntries.forEach((entry) => createHighlightForEntry(entry));
          });

          window.addEventListener('resize', () => {
            if (resizeDebounce) clearTimeout(resizeDebounce);
            resizeDebounce = setTimeout(positionTips, 80);
          });
          window.addEventListener('scroll', () => {
            if (resizeDebounce) clearTimeout(resizeDebounce);
            resizeDebounce = setTimeout(positionTips, 80);
          }, true);

          if (!repositionObserver) {
            repositionObserver = new MutationObserver(mutationHandler);
          }

          try {
            repositionObserver.observe(document.body, { childList: true, subtree: true, attributes: true, attributeFilter: ['style','class'] });
          } catch (e) {}

          setTimeout(() => {
            closeHandler = () => closeHelp();
            document.addEventListener('click', closeHandler);
          }, 0);
        }

        function closeHelp() {

          tipEntries.forEach(t => {
            if (t.tipEl && t.tipEl.parentNode) t.tipEl.parentNode.removeChild(t.tipEl);
            if (t.highlightEl && t.highlightEl.parentNode) t.highlightEl.parentNode.removeChild(t.highlightEl);
            if (t.highlightTimer) clearTimeout(t.highlightTimer);
          });
          tipEntries = [];
          helpOverlay.style.display = 'none';
          helpOverlay.setAttribute('aria-hidden', 'true');

          window.removeEventListener('resize', positionTips);
          window.removeEventListener('scroll', positionTips, true);
          if (repositionObserver) {
            try { repositionObserver.disconnect(); } catch (e) {}
            repositionObserver = null;
          }
          if (closeHandler) {
            document.removeEventListener('click', closeHandler);
            closeHandler = null;
          }
          if (resizeDebounce) { clearTimeout(resizeDebounce); resizeDebounce = null; }
          if (mutationDebounce) { clearTimeout(mutationDebounce); mutationDebounce = null; }
        }

        helpBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const isOpen = helpOverlay.style.display === 'block';
          if (isOpen) {
            closeHelp();
          } else {
            openHelp();
          }
        });

        const customizeBtn = document.getElementById('customizeBtn');
        const helpIconBtn = document.getElementById('helpBtn');
        function triggerAnimation(el, cls) {
          if (!el) return;
          el.classList.remove(cls);
          void el.offsetWidth;
          el.classList.add(cls);
          const onEnd = () => { el.classList.remove(cls); el.removeEventListener('animationend', onEnd); };
          el.addEventListener('animationend', onEnd);
        }
        if (customizeBtn) {
          customizeBtn.addEventListener('click', (e) => {
            triggerAnimation(customizeBtn, 'rotate-center');
          });
        }
        if (helpIconBtn) {
          helpIconBtn.addEventListener('click', (e) => {
            triggerAnimation(helpIconBtn, 'rotate-bottom');
          });
        }

        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && helpOverlay.style.display === 'block') closeHelp();
        });

        window.addEventListener('orientationchange', () => { if (helpOverlay.style.display === 'block') positionTips(); });
      })();
    
      window.addEventListener("DOMContentLoaded", async () => {
        await loadLibrary("zip");
        await loadLibrary("pickr");
        await loadLibrary("pickrCSS", true);
        const savedMode = localStorage.getItem("displayMode") || "dark";
        switchMode(savedMode);
        const savedBgName = localStorage.getItem("bgImageName");
        if (savedBgName) {
          document.getElementById("bgText").textContent = "当前背景:" + savedBgName;
        }

        createColorPicker("#textColorInput", "textColor", (val) => {
          document.body.style.color = val;
        }, "rgba(56,56,56,1)");
      
        createColorPicker("#bgColorInput", "bgColor", (val) => {
          document.body.style.backgroundColor = val;
        }, "rgba(255,255,255,1)");
      
        createColorPicker("#overlayColorInput", "overlayColor", (val) => {
          document.getElementById("overlayPanel").style.backgroundColor = val;
        }, "rgba(255,255,255,0)");        
      
        const skipCheckbox = document.getElementById("skipEncryption");
        const aesCheckbox = document.getElementById("useAdvancedAES");
        const clearBtn = document.getElementById("clearKeyBtn");
        const keyPanel = document.getElementById("keyPanel");
        const button = document.querySelector("button[onclick='toggleKey()']");      
        const keyPanelOpen = localStorage.getItem("keyPanelOpen") === "true";      
        if (keyPanelOpen) {
          clearBtn.classList.remove("hidden");
          keyPanel.classList.remove("hidden");
        } else {
          clearBtn.classList.add("hidden");
          keyPanel.classList.add("hidden");
        }
        const isHidden = keyPanel.classList.contains("hidden");
        button.textContent = isHidden ? "加密处理配置" : "隐藏加密配置";
        skipCheckbox.checked = localStorage.getItem("skipEncryption") === "true";
        aesCheckbox.checked = localStorage.getItem("useAdvancedAES") === "true";
        skipCheckbox.addEventListener("change", () => {
        localStorage.setItem("skipEncryption", skipCheckbox.checked);
        });
        aesCheckbox.addEventListener("change", () => {
          localStorage.setItem("useAdvancedAES", aesCheckbox.checked);
        });
      });

        function _resolveBtn(elOrId) {
          if (typeof elOrId === 'string') return document.getElementById(elOrId);
          return elOrId;
        }

        function setButtonProgress(btnOrId, fraction) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          const f = Math.max(0, Math.min(1, Number(fraction) || 0));
          btn.classList.add('progressing');
          btn.classList.remove('indeterminate', 'finished');
          btn.style.setProperty('--progress', (f * 100) + '%');
          btn.setAttribute('aria-valuemin', '0');
          btn.setAttribute('aria-valuemax', '100');
          btn.setAttribute('aria-valuenow', Math.round(f * 100));
        }

        function startIndeterminate(btnOrId) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          btn.classList.add('indeterminate');
          btn.classList.add('progressing');
          btn.style.setProperty('--progress', '35%');
        }

        function clearButtonProgress(btnOrId) {
          const btn = _resolveBtn(btnOrId);
          if (!btn) return;
          btn.classList.add('finished');
          setTimeout(() => {
            btn.classList.remove('progressing', 'indeterminate', 'finished');
            btn.style.setProperty('--progress', '0%');
            btn.removeAttribute('aria-valuenow');
          }, 260);
        }
    </script>
  </div>
</body>
</html>
